{"version":3,"file":"common.js","sources":["src/vdom.js"],"sourcesContent":["import {\n    d,\n    updateAttribute,\n    appendChild,\n    createElement,\n    createTextNode,\n    isFunc,\n    isObj,\n    isString,\n    isArray,\n    removeListener,\n    addListener,\n    objectIsEmpty,\n    toLowerCase,\n    IS_NON_DIMENSIONAL\n} from \"./utils\";\n\n// modified version of https://github.com/jorgebucaran/superfine\n\nvar removeChild = (parent, child) => parent.removeChild(child),\n    insertBefore = (parent, node, targetNode) => parent.insertBefore(node, targetNode),\n    RECYCLED_NODE = 1,\n    TEXT_NODE = 3,\n    EMPTY_OBJ = {},\n    EMPTY_ARR = [],\n    map = EMPTY_ARR.map,\n\n    //fragment type for host node\n    HOST_TYPE = '#document-fragment',\n\n    Fragment = (props, children) => children,\n\n    merge = (a, b, out) => {\n        out = {};\n        for (var k in a) out[k] = a[k];\n        for (var k in b) out[k] = b[k];\n        return out\n    },\n    listener = function (event) {\n        this.handlers[event.type](event)\n    },\n    remHandle = node => {\n        if (!objectIsEmpty(node.handlers)) {\n            for (let k in node.handlers) {\n                removeListener(node, k, listener);\n                delete node.handlers[k]\n            }\n        }\n    },\n    /* used inside web component disconnect callback*/\n    removeHandlers = dom => {\n        remHandle(dom);\n        [].concat(...dom.childNodes).forEach(child => {\n            remHandle(child)\n            removeHandlers(child);\n        });\n    },\n\n    /* ------------ preact's style property */\n    checkForPx = (key, value) => typeof value === 'number' && IS_NON_DIMENSIONAL.test(key) === false ? value + 'px' : value,\n    setStyle = (style, key, value, noCheckNeeded) => {\n        key[0] === '-' ? style.setProperty(key, value) :\n            style[key] = !noCheckNeeded ? checkForPx(key, value) : value;\n    },\n    styleNode = (dom, newValue, oldValue) => {\n        let _s = dom.style;\n        if (isString(newValue)) return _s.cssText = newValue;\n        if (isString(oldValue)) (_s.cssText = '', oldValue = null);\n        if (oldValue) for (let i in oldValue) if (!(newValue && i in newValue)) setStyle(_s, i, '');\n        if (newValue) for (let i in newValue) if (!oldValue || newValue[i] !== oldValue[i]) setStyle(_s, i, newValue[i]);\n    },\n    /* ------------ */\n\n    // i like how stencil has this built in so i figured id try to include it here\n    // optionally pass objects to className for easy conditional classes ex: className={{activeClassName: someBooleanVariable}}\n    cnObj = (obj, out) => {\n        out = \"\";\n        for (let k in obj) if (obj[k]) out += (out && \" \") + k;\n        return out;\n    },\n\n    // split the classNames up into an array and filter them\n    parseClassList = value => (!value) ? [] : value.split(/\\s+/).filter(c => c),\n    getClassList = value => parseClassList(isObj(value) ? cnObj(value) : value),\n    updateClassList = (node, value, action) =>\n        getClassList(value).forEach(cls => node.classList[action](cls)),\n\n\n    patchProperty = (node, key, oldValue, newValue, isSvg) => {\n        if (key === \"key\" || key === 'children') {\n        } else if (key.startsWith('on') && !(key in node)) {\n            /*\n                referencing stencil's set accessor functionality for many kinds of 'on'-event names\n                cuz \"custom\" event names defined by the user within web components may also start with 'on' like onMyCustomEvent\n                https://github.com/ionic-team/stencil/blob/master/src/runtime/vdom/set-accessor.ts\n             */\n            let eventType = (toLowerCase(key) in node)\n                ? toLowerCase(key.slice(2))\n                : toLowerCase(key[2]) + key.substring(3);\n            // console.log(key, eventType)\n            if (newValue) {\n                if (!oldValue) addListener(node, eventType, listener);\n                (node.handlers || (node.handlers = {}))[eventType] = newValue\n            } else removeListener(node, eventType, listener)\n\n        } else if (key === 'ref' && isFunc(newValue)) newValue(node);\n\n        else if (key === 'style') styleNode(node, newValue, oldValue);\n\n        else if (key === 'className' || key === 'class') {\n\n            updateClassList(node, oldValue, 'remove');\n            updateClassList(node, newValue, 'add');\n\n        } else if (!isSvg && key !== \"list\" && (key in node)) node[key] = newValue == null ? \"\" : newValue;\n        else {\n\n            updateAttribute(node, key, newValue)\n        }\n    },\n\n    createNode = (vnode, isSvg) => {\n        var node = vnode.type === TEXT_NODE\n            ? createTextNode(vnode.name)\n            : (isSvg = isSvg || vnode.name === \"svg\")\n                ? d.createElementNS(\"http://www.w3.org/2000/svg\", vnode.name)\n                /*\n                    implements the use of a document fragment as a pseudo host element\n                    * works with the root element in a web component\n                    return(\n                        <Host> // uses #document-fragment as the h.name\n                            <my-element/>\n                            <my-box/>\n                        </Host>\n                     )\n                */\n                : (vnode.name === HOST_TYPE)\n                    ? d.createDocumentFragment()\n                    : createElement(vnode.name),\n\n            props = vnode.props;\n\n        for (var k in props) node.nodeName !== HOST_TYPE && patchProperty(node, k, null, props[k], isSvg);\n        for (var i = 0, len = vnode.children.length; i < len; i++) appendChild(node, createNode(vnode.children[i], isSvg));\n        return (vnode.node = node)\n    },\n\n    getKey = (vnode) => vnode == null ? null : vnode.key,\n    /*\n       Looked at Atomico's code (which uses vdom in web components) and noticed the destroy method\n       on the web component base component. Since its the shadow dom, it may be possible that the child\n       nodes aren't being looked over???? checked the handlers and they were'nt being removed so i added\n       this to clean things up.\n     */\n    destroy = (dom) => {\n        removeHandlers(dom);\n        dom.destroy && dom.destroy(dom);\n        return dom;\n    },\n\n    patchNode = (parent, node, oldVNode, newVNode, isSvg) => {\n\n        if (oldVNode === newVNode) {\n        } else if (\n            oldVNode != null &&\n            oldVNode.type === TEXT_NODE &&\n            newVNode.type === TEXT_NODE\n        ) {\n            if (oldVNode.name !== newVNode.name) node.nodeValue = newVNode.name\n        } else if (oldVNode == null || oldVNode.name !== newVNode.name) {\n            node = insertBefore(parent, createNode(newVNode, isSvg), node)\n            if (oldVNode != null) removeChild(parent, destroy(oldVNode.node))\n        } else {\n            var tmpVKid,\n                oldVKid,\n                oldKey,\n                newKey,\n                oldVProps = oldVNode.props,\n                newVProps = newVNode.props,\n                oldVKids = oldVNode.children,\n                newVKids = newVNode.children,\n                oldHead = 0,\n                newHead = 0,\n                oldTail = oldVKids.length - 1,\n                newTail = newVKids.length - 1;\n\n            isSvg = isSvg || newVNode.name === \"svg\";\n\n            for (var key in merge(oldVProps, newVProps)) {\n                var _old = oldVProps[key], _new = newVProps[key];\n\n                if ((['value', 'selected', 'checked'].includes(key) ? node[key] : _old) !== _new) {\n                    newVNode.name !== HOST_TYPE && patchProperty(node, key, _old, _new, isSvg)\n                }\n            }\n\n            while (newHead <= newTail && oldHead <= oldTail) {\n                if (\n                    (oldKey = getKey(oldVKids[oldHead])) == null ||\n                    oldKey !== getKey(newVKids[newHead])\n                ) {\n                    break\n                }\n\n                patchNode(\n                    node,\n                    oldVKids[oldHead].node,\n                    oldVKids[oldHead++],\n                    newVKids[newHead++],\n                    isSvg\n                )\n            }\n\n            while (newHead <= newTail && oldHead <= oldTail) {\n                if (\n                    (oldKey = getKey(oldVKids[oldTail])) == null ||\n                    oldKey !== getKey(newVKids[newTail])\n                ) {\n                    break\n                }\n\n                patchNode(\n                    node,\n                    oldVKids[oldTail].node,\n                    oldVKids[oldTail--],\n                    newVKids[newTail--],\n                    isSvg\n                )\n            }\n\n            if (oldHead > oldTail) {\n                while (newHead <= newTail) {\n                    insertBefore(node,\n                        createNode(newVKids[newHead++], isSvg),\n                        (oldVKid = oldVKids[oldHead]) && oldVKid.node\n                    )\n                }\n            } else if (newHead > newTail) {\n                while (oldHead <= oldTail) {\n                    removeChild(node, destroy(oldVKids[oldHead++].node))\n                }\n            } else {\n                for (var i = oldHead, keyed = {}, newKeyed = {}; i <= oldTail; i++) {\n                    if ((oldKey = oldVKids[i].key) != null) {\n                        keyed[oldKey] = oldVKids[i]\n                    }\n                }\n\n                while (newHead <= newTail) {\n                    oldKey = getKey((oldVKid = oldVKids[oldHead]))\n                    newKey = getKey(newVKids[newHead])\n\n                    if (\n                        newKeyed[oldKey] ||\n                        (newKey != null && newKey === getKey(oldVKids[oldHead + 1]))\n                    ) {\n                        if (oldKey == null) removeChild(node, destroy(oldVKid.node))\n                        oldHead++\n                        continue\n                    }\n\n                    if (newKey == null || oldVNode.type === RECYCLED_NODE) {\n                        if (oldKey == null) {\n                            patchNode(\n                                node,\n                                oldVKid && oldVKid.node,\n                                oldVKid,\n                                newVKids[newHead],\n                                isSvg\n                            )\n                            newHead++\n                        }\n                        oldHead++\n                    } else {\n                        if (oldKey === newKey) {\n                            patchNode(node, oldVKid.node, oldVKid, newVKids[newHead], isSvg)\n                            newKeyed[newKey] = true\n                            oldHead++\n                        } else {\n                            if ((tmpVKid = keyed[newKey]) != null) {\n                                patchNode(\n                                    node,\n                                    insertBefore(node, tmpVKid.node, oldVKid && oldVKid.node),\n                                    tmpVKid,\n                                    newVKids[newHead],\n                                    isSvg\n                                )\n                                newKeyed[newKey] = true\n                            } else {\n                                patchNode(\n                                    node,\n                                    oldVKid && oldVKid.node,\n                                    null,\n                                    newVKids[newHead],\n                                    isSvg\n                                )\n                            }\n                        }\n                        newHead++\n                    }\n                }\n\n                while (oldHead <= oldTail)\n                    if (getKey((oldVKid = oldVKids[oldHead++])) == null) removeChild(node, destroy(oldVKid.node));\n\n                for (var i in keyed) if (newKeyed[i] == null) removeChild(node, destroy(keyed[i].node))\n            }\n        }\n        return (newVNode.node = node)\n    },\n\n    createVNode = (name, props, children, node, key, type) => ({name, props, children, node, type, key}),\n\n    createTextVNode = (value, node) => createVNode(value, EMPTY_OBJ, EMPTY_ARR, node, null, TEXT_NODE),\n\n    recycleNode = (node) => {\n        let results = node.nodeType === TEXT_NODE\n            ? createTextVNode(node.nodeValue, node)\n            : createVNode(\n                toLowerCase(node.nodeName),\n                EMPTY_OBJ,\n                map.call(node.childNodes, recycleNode),\n                node,\n                null,\n                RECYCLED_NODE\n            );\n        return results;\n    },\n\n    patch = (node, vdom) => {\n        //using template as a workaround since template tags have a document fragment as first child\n        if (!node.__mountPoint) appendChild(node, (node.__mountPoint = createElement(vdom.name === HOST_TYPE ? 'template' : vdom.name)));\n        let nodeToPatch = (vdom.name === HOST_TYPE && node.nodeName === HOST_TYPE) ? node : node.__mountPoint;\n        (node = node.__mountPoint = patchNode(\n            nodeToPatch.parentNode, //parent\n            nodeToPatch, // node\n            nodeToPatch.vdom || recycleNode(nodeToPatch), //oldVNode\n            vdom // newVNode\n        )).vdom = vdom;\n        return node\n    },\n\n\n    h = function (name, props) {\n        for (var vnode, rest = [], children = [], i = arguments.length; i-- > 2;) rest.push(arguments[i]);\n        if ((props = props == null ? {} : props).children != null) {\n            if (rest.length <= 0) rest.push(props.children);\n            delete props.children;\n        }\n        while (rest.length > 0) {\n            if (isArray((vnode = rest.pop()))) {\n                for (var i = vnode.length; i-- > 0;) rest.push(vnode[i])\n            } else if (vnode === false || vnode === true || vnode == null) {\n            } else children.push(typeof vnode === 'object' ? vnode : createTextVNode(vnode));\n        }\n        return isFunc(name)\n            ? (props.children = props.children || children) && name(props)\n            : createVNode(name, props, children, null, props.key)\n    };\n\n\nexport {patch, h, Fragment, removeHandlers, HOST_TYPE, patchProperty, merge, parseClassList, cnObj, styleNode, setStyle}\n"],"names":["removeChild","parent","child","insertBefore","node","targetNode","EMPTY_OBJ","EMPTY_ARR","map","HOST_TYPE","Fragment","props","children","listener","event","handlers","type","remHandle","objectIsEmpty","k","removeListener","removeHandlers","dom","concat","childNodes","forEach","setStyle","style","key","value","noCheckNeeded","setProperty","IS_NON_DIMENSIONAL","test","checkForPx","updateClassList","action","split","filter","c","parseClassList","isObj","obj","out","cnObj","getClassList","cls","classList","patchProperty","oldValue","newValue","isSvg","startsWith","isFunc","_s","isString","cssText","i","styleNode","updateAttribute","eventType","toLowerCase","slice","substring","addListener","createNode","vnode","createTextNode","name","d","createElementNS","createDocumentFragment","createElement","nodeName","len","length","appendChild","getKey","destroy","patchNode","oldVNode","newVNode","nodeValue","tmpVKid","oldVKid","oldKey","newKey","oldVProps","newVProps","oldVKids","newVKids","oldHead","newHead","oldTail","newTail","a","b","merge","_old","_new","includes","keyed","newKeyed","createVNode","createTextVNode","recycleNode","nodeType","call","patch","vdom","__mountPoint","nodeToPatch","parentNode","h","rest","arguments","push","isArray","pop"],"mappings":"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"}