{"version":3,"file":"index.js","sources":["../src/vdom.js","../src/Component.js"],"sourcesContent":["import {\n    d,\n    updateAttribute,\n    appendChild,\n    createElement,\n    createTextNode,\n    isFunc,\n    isObj,\n    isString,\n    isArray,\n    removeListener,\n    addListener,\n    objectIsEmpty,\n    toLowerCase,\n    COMPONENT_MOUNTED_ATTRIBUTE,\n    IS_NON_DIMENSIONAL\n} from \"./utils\";\n\n// modified version of https://github.com/jorgebucaran/superfine\n\nvar removeChild = (parent, child) => parent.removeChild(child),\n    insertBefore = (parent, node, targetNode) => parent.insertBefore(node, targetNode),\n    RECYCLED_NODE = 1,\n    TEXT_NODE = 3,\n    EMPTY_OBJ = {},\n    EMPTY_ARR = [],\n    map = EMPTY_ARR.map,\n    NULL = null,\n\n    //fragment type for host node\n    HOST_TYPE = '#document-fragment',\n\n    Fragment = (props, children) => children,\n\n    merge = (a, b, out) => {\n        out = {};\n        for (var k in a) out[k] = a[k];\n        for (var k in b) out[k] = b[k];\n        return out\n    },\n\n    listener = function (event) {\n        this.handlers[event.type](event)\n    },\n\n    remHandle = node => {\n        if (!objectIsEmpty(node.handlers)) {\n            for (let k in node.handlers) {\n                removeListener(node, k, listener);\n                delete node.handlers[k]\n            }\n        }\n    },\n    /* used inside web component disconnect callback*/\n    removeHandlers = dom => {\n        remHandle(dom);\n        [].concat(...dom.childNodes).forEach(child => {\n            remHandle(child)\n            removeHandlers(child);\n        });\n    },\n\n    /* ------------ preact's style property */\n\n\n    checkForPx = (key, value) => typeof value === 'number' && IS_NON_DIMENSIONAL.test(key) === false ? value + 'px' : value,\n    setStyle = (style, key, value, noCheckNeeded) => {\n        key[0] === '-' ? style.setProperty(key, value) :\n            style[key] = !noCheckNeeded ? checkForPx(key, value) : value;\n    },\n    styleNode = (dom, newValue, oldValue) => {\n        let _s = dom.style;\n        if (isString(newValue)) return _s.cssText = newValue;\n        if (isString(oldValue)) (_s.cssText = '', oldValue = NULL);\n        if (oldValue) for (let i in oldValue) if (!(newValue && i in newValue)) setStyle(_s, i, '');\n        if (newValue) for (let i in newValue) if (!oldValue || newValue[i] !== oldValue[i]) setStyle(_s, i, newValue[i]);\n    },\n\n    /* ------------ */\n\n    // i like how stencil has this built in so i figured id try to include it here\n    // optionally pass objects to className for easy conditional classes ex: className={{activeClassName: someBooleanVariable}}\n    cnObj = (obj, out) => {\n        out = \"\";\n        for (let k in obj) if (obj[k]) out += (out && \" \") + k;\n        return out;\n    },\n\n    // split the classNames up into an array and filter them\n    parseClassList = value => (!value) ? [] : value.split(/\\s+/).filter(c => c),\n    getClassList = value => parseClassList(isObj(value) ? cnObj(value) : value),\n    updateClassList = (node, value, action) =>\n        getClassList(value).forEach(cls => node.classList[action](cls)),\n\n\n    patchProperty = (node, key, oldValue, newValue, isSvg) => {\n        if (key === \"key\") {\n        } else if (key.startsWith('on') && !(key in node)) {\n            /*\n                referencing stencil's set accessor functionality for many kinds of 'on'-event names\n                cuz \"custom\" event names defined by the user within web components may also start with 'on' like onMyCustomEvent\n                https://github.com/ionic-team/stencil/blob/master/src/runtime/vdom/set-accessor.ts\n             */\n            let eventType = (toLowerCase(key) in node)\n                ? toLowerCase(key.slice(2))\n                : toLowerCase(key[2]) + key.substring(3);\n            // console.log(key, eventType)\n            if (newValue) {\n                if (!oldValue) addListener(node, eventType, listener);\n                (node.handlers || (node.handlers = {}))[eventType] = newValue\n            } else removeListener(node, eventType, listener)\n\n        } else if (key === 'ref' && isFunc(newValue)) newValue(node);\n\n        else if (key === 'style') styleNode(node, newValue, oldValue);\n\n        else if (key === 'className' || key === 'class') {\n\n            updateClassList(node, oldValue, 'remove');\n            updateClassList(node, newValue, 'add');\n\n        } else if (!isSvg && key !== \"list\" && (key in node)) node[key] = newValue == NULL ? \"\" : newValue;\n        else {\n\n            updateAttribute(node, key, newValue)\n        }\n    },\n\n    createNode = (vnode, isSvg) => {\n        var node = vnode.type === TEXT_NODE\n            ? createTextNode(vnode.name)\n            : (isSvg = isSvg || vnode.name === \"svg\")\n                ? d.createElementNS(\"http://www.w3.org/2000/svg\", vnode.name)\n\n                /*\n                    implements the use of a document fragment as a pseudo host element\n                    * works with the root element in a web component\n                    return(\n                        <Host> // uses #document-fragment as the h.name\n                            <my-element/>\n                            <my-box/>\n                        </Host>\n                     )\n                */\n                : (vnode.name === HOST_TYPE)\n                    ? d.createDocumentFragment()\n                    : createElement(vnode.name),\n\n            props = vnode.props;\n\n        for (var k in props) node.nodeName !== HOST_TYPE && patchProperty(node, k, NULL, props[k], isSvg);\n        for (var i = 0, len = vnode.children.length; i < len; i++) appendChild(node, createNode(vnode.children[i], isSvg));\n        return (vnode.node = node)\n    },\n\n    getKey = (vnode) => vnode == NULL ? NULL : vnode.key,\n    /*\n       Looked at Atomico's code (which uses vdom in web components) and noticed the destroy method\n       on the web component base component. Since its the shadow dom, it may be possible that the child\n       nodes aren't being looked over???? checked the handlers and they were'nt being removed so i added\n       this to clean things up.\n     */\n    destroy = (dom) => {\n        removeHandlers(dom);\n        dom.destroy && dom.destroy(dom);\n        return dom;\n    },\n\n    patchNode = (parent, node, oldVNode, newVNode, isSvg) => {\n\n\n        if (oldVNode === newVNode) {\n        } else if (\n            oldVNode != NULL &&\n            oldVNode.type === TEXT_NODE &&\n            newVNode.type === TEXT_NODE\n        ) {\n            if (oldVNode.name !== newVNode.name) node.nodeValue = newVNode.name\n        } else if (oldVNode == NULL || oldVNode.name !== newVNode.name) {\n            node = insertBefore(parent, createNode(newVNode, isSvg), node)\n            if (oldVNode != NULL) removeChild(parent, destroy(oldVNode.node))\n        } else {\n            var tmpVKid,\n                oldVKid,\n                oldKey,\n                newKey,\n                oldVProps = oldVNode.props,\n                newVProps = newVNode.props,\n                oldVKids = oldVNode.children,\n                newVKids = newVNode.children,\n                oldHead = 0,\n                newHead = 0,\n                oldTail = oldVKids.length - 1,\n                newTail = newVKids.length - 1;\n            isSvg = isSvg || newVNode.name === \"svg\";\n\n            for (var key in merge(oldVProps, newVProps)) {\n                var _old = oldVProps[key], _new = newVProps[key];\n\n                if ((['value', 'selected', 'checked'].includes(key) ? node[key] : _old) !== _new) {\n\n                    newVNode.name !== HOST_TYPE && patchProperty(node, key, _old, _new, isSvg)\n                }\n            }\n\n            while (newHead <= newTail && oldHead <= oldTail) {\n                if (\n                    (oldKey = getKey(oldVKids[oldHead])) == NULL ||\n                    oldKey !== getKey(newVKids[newHead])\n                ) {\n                    break\n                }\n\n                patchNode(\n                    node,\n                    oldVKids[oldHead].node,\n                    oldVKids[oldHead++],\n                    newVKids[newHead++],\n                    isSvg\n                )\n            }\n\n            while (newHead <= newTail && oldHead <= oldTail) {\n                if (\n                    (oldKey = getKey(oldVKids[oldTail])) == NULL ||\n                    oldKey !== getKey(newVKids[newTail])\n                ) {\n                    break\n                }\n\n                patchNode(\n                    node,\n                    oldVKids[oldTail].node,\n                    oldVKids[oldTail--],\n                    newVKids[newTail--],\n                    isSvg\n                )\n            }\n\n            if (oldHead > oldTail) {\n                while (newHead <= newTail) {\n                    insertBefore(node,\n                        createNode(newVKids[newHead++], isSvg),\n                        (oldVKid = oldVKids[oldHead]) && oldVKid.node\n                    )\n                }\n            } else if (newHead > newTail) {\n                while (oldHead <= oldTail) {\n                    removeChild(node, destroy(oldVKids[oldHead++].node))\n                }\n            } else {\n                for (var i = oldHead, keyed = {}, newKeyed = {}; i <= oldTail; i++) {\n                    if ((oldKey = oldVKids[i].key) != NULL) {\n                        keyed[oldKey] = oldVKids[i]\n                    }\n                }\n\n                while (newHead <= newTail) {\n                    oldKey = getKey((oldVKid = oldVKids[oldHead]))\n                    newKey = getKey(newVKids[newHead])\n\n                    if (\n                        newKeyed[oldKey] ||\n                        (newKey != NULL && newKey === getKey(oldVKids[oldHead + 1]))\n                    ) {\n                        if (oldKey == NULL) removeChild(node, destroy(oldVKid.node))\n                        oldHead++\n                        continue\n                    }\n\n                    if (newKey == NULL || oldVNode.type === RECYCLED_NODE) {\n                        if (oldKey == NULL) {\n                            patchNode(\n                                node,\n                                oldVKid && oldVKid.node,\n                                oldVKid,\n                                newVKids[newHead],\n                                isSvg\n                            )\n                            newHead++\n                        }\n                        oldHead++\n                    } else {\n                        if (oldKey === newKey) {\n                            patchNode(node, oldVKid.node, oldVKid, newVKids[newHead], isSvg)\n                            newKeyed[newKey] = true\n                            oldHead++\n                        } else {\n                            if ((tmpVKid = keyed[newKey]) != NULL) {\n                                patchNode(\n                                    node,\n                                    insertBefore(node, tmpVKid.node, oldVKid && oldVKid.node),\n                                    tmpVKid,\n                                    newVKids[newHead],\n                                    isSvg\n                                )\n                                newKeyed[newKey] = true\n                            } else {\n                                patchNode(\n                                    node,\n                                    oldVKid && oldVKid.node,\n                                    NULL,\n                                    newVKids[newHead],\n                                    isSvg\n                                )\n                            }\n                        }\n                        newHead++\n                    }\n                }\n\n                while (oldHead <= oldTail)\n                    if (getKey((oldVKid = oldVKids[oldHead++])) == NULL) removeChild(node, destroy(oldVKid.node));\n\n                for (var i in keyed) if (newKeyed[i] == NULL) removeChild(node, destroy(keyed[i].node))\n            }\n        }\n        return (newVNode.node = node)\n    },\n    createVNode = (name, props, children, node, key, type) => ({name, props, children, node, type, key}),\n    createTextVNode = (value, node) => createVNode(value, EMPTY_OBJ, EMPTY_ARR, node, NULL, TEXT_NODE),\n    recycleNode = (node) =>\n        node.nodeType === TEXT_NODE\n            ? createTextVNode(node.nodeValue, node)\n            : createVNode(\n            toLowerCase(node.nodeName),\n            EMPTY_OBJ,\n            map.call(node.childNodes, recycleNode),\n            node,\n            NULL,\n            RECYCLED_NODE\n            ),\n\n    patch = (node, vdom) => (\n        ((node = patchNode(\n            node.parentNode,\n            node,\n            node.vdom || recycleNode(node),\n            vdom\n        )).vdom = vdom),\n            node\n    ),\n    h = function (name, props) {\n        for (var vnode, rest = [], children = [], i = arguments.length; i-- > 2;) rest.push(arguments[i]);\n        while (rest.length > 0) {\n            if (isArray((vnode = rest.pop()))) {\n                for (var i = vnode.length; i-- > 0;) rest.push(vnode[i])\n            } else if (vnode === false || vnode === true || vnode == NULL) {\n            } else children.push(isObj(vnode) ? vnode : createTextVNode(vnode));\n        }\n        props = props || EMPTY_OBJ\n        return isFunc(name)\n            ? name(props, children)\n            : createVNode(name, props, children, NULL, props.key)\n    };\n\nexport {patch, h, Fragment, removeHandlers, HOST_TYPE, patchProperty, merge, parseClassList, cnObj, styleNode, setStyle}\n\n","import {\n    formatType,\n    updateAttribute,\n    propToAttr,\n    attrToProp,\n    webComponentVisibility,\n    createElement,\n    appendChild,\n    TEST_ENV,\n    def, extend, isFunc, isObj, objectIsEmpty,\n    COMPONENT_MOUNTED_ATTRIBUTE,\n    globalStyles,\n    raf,\n    isArray,\n    CSSTextToObj,\n    webComponentVisibilityStyleSheet,\n    tagStyleCache,\n    CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE\n} from \"./utils\";\n\n\nimport {\n    h,\n    patch,\n    removeHandlers,\n    HOST_TYPE,\n    patchProperty,\n} from \"./vdom\";\n\n\n// PROPS = Symbol(),\nlet PROPS = 'props',\n    IGNORE_ATTR = Symbol(),\n    DEFAULT_SHADOWROOT_HOST_CSS_RESETS = `:host, *, *::before, *::after {box-sizing: border-box;} `,\n    context = {};\n\nexport const provide = (namespace, attach) => context[namespace] = attach;\n\n\nwebComponentVisibilityStyleSheet(`[${COMPONENT_MOUNTED_ATTRIBUTE}] {visibility: inherit;}`);\n\n/* lots of inspiration from superfine, atomico, stencil, and preact*/\nexport class Component extends HTMLElement {\n\n    context = context;\n\n    _unsubs = [];\n\n    state = {};\n\n    constructor() {\n        super();\n        // the statically set fields from the class that extends this\n        let {initAttrs, shadow, rootSheet, noRerender, tag} = this.constructor;\n\n        let root = !shadow ? this : this.attachShadow({mode: ['open', 'closed'].includes(shadow) ? shadow : 'open'});\n\n        this[PROPS] = {};\n\n        this.render = this.render.bind(this);\n\n        // store a pending promise to mounted.\n        // Promise is resolved in connectedCallback when mount is called\n        this.mounted = new Promise(mount => (this._mount = mount));\n\n\n        /**\n         * adopts style sheets to the shadowRoot or the document\n         * @param sheets {array|CSSStyleSheet}\n         * @returns {string}\n         */\n        const adoptSheets = (sheets) => {\n            let adopter = shadow ? root : document;\n            let combinedCSSTextIfNotAdoptable = '';\n\n            sheets.forEach(customArrayOrSheet => {\n                if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE) {\n                    // check if the style sheet was created with createStyleSheet()\n                    let sheet = isArray(customArrayOrSheet) ? customArrayOrSheet[0] : customArrayOrSheet;\n                    if (sheet && !([].concat(adopter.adoptedStyleSheets).includes(sheet))) {\n                        adopter.adoptedStyleSheets = [...adopter.adoptedStyleSheets, sheet];\n                    }\n                } else if (isArray(customArrayOrSheet) && customArrayOrSheet[1]) {\n                    combinedCSSTextIfNotAdoptable = combinedCSSTextIfNotAdoptable + customArrayOrSheet[1]\n                }\n            });\n            return combinedCSSTextIfNotAdoptable\n        };\n\n        if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE) adoptSheets([rootSheet]);\n        let hasAdoptedExternalSheets = false;\n        /**\n         * optionally use constructable style sheets with fall backs if not supported\n         * @param css {string} - css text\n         * @param noResets {boolean} - exclude the default box-sizing reset on the :host\n         * @param globalFallback {boolean} - if no constructableStylesheets then optionally allow a style tag in the head of the document instead of a style tag\n         * @param useStyleTag {boolean} - use a style tag even if constructableStylesheets\n         * @param styleSheets {array} - an array of style sheets made with createStyleSheet\n         * @param children - child vNodes\n         * @returns {*}\n         */\n        const CSS = ({css, noResets, globalFallback, useStyleTag, styleSheets}, children) => {\n            // get the cssText from the props or the first child vNode.\n            let cssText = css || isObj(children[0]) && children[0].name || '';\n            // if using shadow then include the resets by default if noResets is not explicitly set to true.\n            if (!noResets && shadow) cssText = DEFAULT_SHADOWROOT_HOST_CSS_RESETS + cssText;\n            let combinedCSSTextIfNotAdoptable = '';\n            // adopt the external styleSheets only once.\n            if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE && !hasAdoptedExternalSheets && isArray(styleSheets)) {\n                combinedCSSTextIfNotAdoptable = adoptSheets(styleSheets);\n                hasAdoptedExternalSheets = true;\n            }\n            // if no constructableStylesheets and opting-in to a style tag in the head of the document\n            // and the styles have not already been placed (checking tagStyleCache),\n            // then set them only once\n            if (!CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE && globalFallback && !tagStyleCache[tag]) {\n                tagStyleCache[tag] = true;\n                globalStyles(cssText + combinedCSSTextIfNotAdoptable);\n                return null;\n            } else if (!CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE || useStyleTag) { // fallback to a style tag or opt-in\n                return <style>{cssText + combinedCSSTextIfNotAdoptable}</style>;\n            } else if (rootSheet.cssRules.length === 0) { // apply the cssText\n                rootSheet.replaceSync(cssText);\n                return null\n            }\n            return null;\n        };\n\n        let usingVHost, lastSelfHostPropsEmpty;\n\n        const Host = (selfProps, children) => {\n            usingVHost = true; // let the renderers know that we are using a vHost node\n            let kids = h(HOST_TYPE, {}, children);\n            //can skip patching the host props during the first render if no props are provided\n            if (!this.hasMounted && objectIsEmpty(selfProps)) return (lastSelfHostPropsEmpty = true, kids);\n            if (lastSelfHostPropsEmpty && objectIsEmpty(selfProps)) return kids;\n            lastSelfHostPropsEmpty = false;\n            // convert the attributes from this element into props format\n            let hostNodeProps = {}, i = 0, a = this.attributes;\n            for (i = a.length; i--;) {\n                let attr = a[i].name;\n                hostNodeProps[attr === 'class' ? 'className' : attr] = a[i].value;\n            }\n            //apply host vnode props on 'this', merge in and potentially override individual properties that exist\n            for (let key in selfProps) patchProperty(this, key, hostNodeProps[key], selfProps[key]);\n            return kids;\n        };\n\n        this.setState = nextState => {\n            extend(this.state, isFunc(nextState) ? nextState(this.state) : nextState || {});\n            return this.update();\n        };\n\n        this.observeObi = (...obis) =>\n            obis.forEach(obi => obi.$onChange && this._unsubs.push(obi.$onChange(this.update)));\n\n        const renderArgs = () => {\n            // if watching the style property, convert the style string ('width:100%;') into an object ({width: '100%'})\n            if (this._watchesForStyleUpdates) this[PROPS].style = CSSTextToObj(this.style.cssText);\n            return [\n                extend({Host, CSS, host: this}, this[PROPS]),\n                this.state,\n                this.context\n            ];\n        };\n\n        let base, noRenderResults;\n\n        const initialRenderer = () => {\n            let next = renderArgs();\n            this.willMount(...next);\n            this.willRender(...next);\n            let results = this.render(...next);\n            if (results) {\n                // workaround for (the modified version of) superfine.js\n                // since superfine replaces the node that it mounts to, we need to provide one.\n                let mountPoint = createElement(usingVHost ? 'template' : results.name);\n                appendChild(root, mountPoint);\n                // if using vHost and shadowDom then patch the root, else patch the mount point\n                base = patch(usingVHost && shadow ? root : mountPoint, results);\n            } else noRenderResults = true;\n            let postInitial = () => {\n                this._unsubs.push(this.lifeCycle()); // optionally return subscriptions to unsub on detach\n                // adding visibility inherit next tick after render will prevent flash of un-styled content. (inspired by stencil.js)\n                // Removing this functionality during testing makes life easier.\n                !TEST_ENV && updateAttribute(this, COMPONENT_MOUNTED_ATTRIBUTE, '');\n                this.didRender(...next);\n                this.didMount(...next);\n            };\n            this.hasMounted = true;\n            !TEST_ENV ? raf(postInitial) : postInitial();\n        };\n\n        const subsequentRenderer = () => {\n            let next = renderArgs();\n            let shouldRerender = this.willRender(...next); //\n            if (this.shouldUpdate) shouldRerender = this.shouldUpdate(...next);\n            // returning a falsy value other than undefined will prevent rerender\n            if (noRerender || noRenderResults || (!shouldRerender && (shouldRerender !== undefined))) return;\n            this.willUpdate(...next);\n            patch(usingVHost && shadow ? root : base, this.render(...next));\n            this.didUpdate(...next);\n            this.didRender(...next);\n        };\n\n        this.update = () => {\n            if (!this.processing) this.processing = this.mounted.then(_ => {\n                !this.hasMounted ? initialRenderer() : subsequentRenderer();\n                this.processing = false;\n            });\n            return this.processing;\n        };\n\n        this.emit = (name, detail, from, options) => (from || this).dispatchEvent(\n            new CustomEvent(name, extend({detail, bubbles: true, composed: true}, options || {}))\n        );\n\n        let destroyed;\n\n        this.destroy = (dom) => {\n            if (!destroyed) {\n                dom && removeHandlers(dom);\n                this._unsubs.forEach(fn => isFunc(fn) && fn());\n                destroyed = true;\n            }\n        };\n\n\n\n        let length = initAttrs.length;\n        while (length--) initAttrs[length](this);\n\n        this.update();\n    }\n\n    connectedCallback() {\n        // connected callback may be called inadvertently, so check this.\n        if (this.hasMounted) return;\n        // if state is using an obi (mini observable object) then push the sub into unsubs\n        this.state.$onChange && this._unsubs.push(this.state.$onChange(this.update));\n        this.observe && this.observeObi(this.observe);\n        // resolve the pending promise that was set to this.mounted.\n        this._mount();\n    }\n\n    disconnectedCallback() {\n        // the component may inadvertently call this, so check if its connected before calling destroy.\n        // can happen if the node is being moved ex:  parent.insertBefore(node, targetNode).\n        if (!this.isConnected) {\n            this.willUnmount();\n            this.destroy();\n        }\n    }\n\n    attributeChangedCallback(attr, oldValue, newValue) {\n        // if we are setting our own attribute that we are tracking, then ignore this update.\n        if (this[IGNORE_ATTR] === attr || oldValue === newValue) return;\n        // opt-in notify for styles\n        if (attr === 'style' && this._watchesForStyleUpdates) this.update();\n        // else convert kabob-case to CamelCase\n        else this[attrToProp(attr)] = newValue;\n    }\n\n    /*  -- a little recap on prototype --\n        When a constructor (a.k.a. pseudo classical inheritance) function is built,\n        the newly created objects inherit the prototype properties of the constructor function\n        and thatâ€™s the critical feature of constructors. They (constructor functions)\n        are built for the initialization of newly created objects.*/\n\n    /*  let the prototype know what attributes to observe\n        called while constructing the class / creating the prototype. */\n    static get observedAttributes() {\n        let {\n            propTypes, // get the statically set propTypes.\n            prototype // prototype - the soon to be - newly instantiated class.\n        } = this; // 'this' will references the constructor when used inside static methods.\n        this.initAttrs = [];\n        if (!propTypes) return [];\n        /* inspired by atomico  */\n        let observedAttr = Object.keys(propTypes).map(prop => {\n            let attr = propToAttr(prop);// convert the camelCase to kabob-case.\n            let schema = propTypes[prop].name ? {type: propTypes[prop]} : propTypes[prop];\n            //dynamically build the setters and getters for the prototype during the construction phase.\n            if (!(prop in prototype)) { // ignores properties that exist, like style and className\n                // def = (obj, prop, handlers) => Object.defineProperty(obj, prop, handlers),\n                def(prototype, prop, {\n                    // keep an internal reference to the observed properties on this.props\n                    // provide an access getter.\n                    get() {// <--- since this is not a lexical scope function aka () => { };\n                        // then 'this' in this scope will reference the prototype.\n                        return this[PROPS][prop]\n                    },\n                    // react to updates when the value is set on the instance.\n                    set(nextValue) {\n                        // format the incoming value into the type that it is defined in on the propTypes object\n                        // ex: if its an Object, then JSON.parse the value\n                        let {value, error} = formatType(nextValue, schema.type);\n                        if (error && value != null) console.error(`[${prop}] must be type [${schema.type.name}]`);\n                        // if the value is the same, then dip out.\n                        if (value === this[PROPS][prop]) return;\n                        // if the value is meant to be reflected\n                        // then set it as an attribute\n                        if (schema.reflect) { // several sequential updates are deferred/debounced with the pending promise\n                            this.mounted.then(() => { // and are only set after the component has finished constructing.\n                                // setting IGNORE_ATTR ignores attribute during attributeChangedCallback\n                                // because we handle our own update.\n                                this[IGNORE_ATTR] = attr;\n                                //either set or remove the attribute.\n                                updateAttribute(\n                                    this,\n                                    attr,\n                                    schema.type === Boolean && !value\n                                        ? null\n                                        : value\n                                    // (!schema.reflect && schema.type === Boolean && value === true) ? '' : value\n                                );\n                                this[IGNORE_ATTR] = false;\n                            });\n                        }\n                        this[PROPS][prop] = value;\n                        this.update();\n                    }\n                });\n            }\n            // prime the default attributes if the propTypes schema has default value.\n            // will initialize in the constructor of the prototype.\n            schema.value && this.initAttrs.push(self => (self[prop] = schema.value));\n            return attr;\n        });\n        // let the prototype know to listen for style changes here since ('style' in prototype) is true\n        // and since we want more control over how the style is updated ex: {...userStyles, ...ourStyles}\n        this.prototype._watchesForStyleUpdates = observedAttr.includes('style');\n        return observedAttr;\n    };\n\n    willMount() { // called once before render\n    }\n\n    willRender() { // called before every render, optionally return false to prevent any further re-rendering\n        // will still render one time\n        // return false; // but no more rendering!\n    }\n\n\n    render() {\n    }\n\n    didRender() { // called after every render\n    }\n\n    willUpdate() { // called before every render besides the first\n    }\n\n    didUpdate() { // called after every render besides the first\n    }\n\n    didMount() { // called once after first render\n    }\n\n    lifeCycle() { // same as didMount but optionally return a callback to be called during willUnmount\n        // return ()=> subscription.unsubscribe();\n    }\n\n    willUnmount() {\n    }\n\n}\n\n\nexport const x = (tag, component, config) => {\n\n    config = config || {};\n\n    webComponentVisibility(tag);\n\n    let rootSheet,\n        isComponent = component.prototype instanceof Component;\n\n    if (CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE) rootSheet = new CSSStyleSheet();\n\n    if (isComponent) {\n        component.rootSheet = rootSheet;\n        component.tag = tag;\n    }\n\n    customElements.define(tag,\n        isComponent ? component : class extends Component {\n            static tag = tag;\n            static propTypes = config.propTypes;\n            static shadow = config.shadow;\n            static rootSheet = rootSheet;\n            static noRerender = config.noRerender;\n            render = component\n        }\n    );\n\n    return (props, children) => h(tag, props, children);\n};\n\n\n/*\n\n\n\n    abstraction for sharing events on the window\n\n    const Events = ()=>{\n        window.addEventListener('dataChange', notifySubs)\n        ...\n        return{\n            emit,\n            on,\n            off,\n        }\n    }\n\n\n    events.emit('dataChange', 'namespace', {loggedIn: true })\n\n    events.on('dataChange', 'namespace', ({loggedIn})=>{\n        //do something\n    });\n\n */\n\n\n/*\n    constructor() {\n        super()\n\n\n        // this._observer = new MutationObserver(this._onMutation);\n    }\n\n\n    _onMutation = mutationsList => {\n        const newProps = mutationsList.reduce((props, mutation) => {\n            if (mutation.type === \"attributes\") {\n                const propKey = mutation.attributeName;\n                props[propKey] = this.getAttribute(propKey);\n            }\n            return props;\n        }, {});\n        // console.log('childlist mutated', mutationsList)\n        // console.log(newProps)\n        // this.update();\n        // this.setProps(newProps);\n    };\n\n    _startObserver = () => {\n\n\n        // this._observer.observe(this, {attributes: true});\n    };\n\n       const handler = {\n            set(target, key, value) {\n                console.log(`Setting value ${key} as ${value}`)\n                target[key] = value;\n            },\n        };\n\n        this.styles = new Proxy(this.style, handler);\n */"],"names":["removeChild","parent","child","insertBefore","node","targetNode","EMPTY_OBJ","EMPTY_ARR","map","HOST_TYPE","Fragment","props","children","listener","event","handlers","type","remHandle","objectIsEmpty","k","removeListener","removeHandlers","dom","concat","childNodes","forEach","setStyle","style","key","value","noCheckNeeded","setProperty","IS_NON_DIMENSIONAL","test","checkForPx","updateClassList","action","split","filter","c","parseClassList","isObj","obj","out","cnObj","getClassList","cls","classList","patchProperty","oldValue","newValue","isSvg","startsWith","isFunc","_s","isString","cssText","i","styleNode","updateAttribute","eventType","toLowerCase","slice","substring","addListener","createNode","vnode","createTextNode","name","d","createElementNS","createDocumentFragment","createElement","nodeName","len","length","appendChild","getKey","destroy","patchNode","oldVNode","newVNode","nodeValue","tmpVKid","oldVKid","oldKey","newKey","oldVProps","newVProps","oldVKids","newVKids","oldHead","newHead","oldTail","newTail","a","b","merge","_old","_new","includes","keyed","newKeyed","createVNode","createTextVNode","recycleNode","nodeType","call","patch","vdom","parentNode","h","rest","arguments","push","isArray","pop","PROPS","IGNORE_ATTR","Symbol","DEFAULT_SHADOWROOT_HOST_CSS_RESETS","context","provide","namespace","attach","webComponentVisibilityStyleSheet","COMPONENT_MOUNTED_ATTRIBUTE","Component","HTMLElement","constructor","_unsubs","state","initAttrs","shadow","rootSheet","noRerender","tag","this","root","attachShadow","mode","render","bind","mounted","Promise","mount","_mount","adoptSheets","sheets","adopter","document","combinedCSSTextIfNotAdoptable","customArrayOrSheet","CONSTRUCTABLE_STYLE_SHEETS_AVAILABLE","sheet","adoptedStyleSheets","hasAdoptedExternalSheets","CSS","css","noResets","globalFallback","useStyleTag","styleSheets","tagStyleCache","cssRules","replaceSync","globalStyles","usingVHost","lastSelfHostPropsEmpty","Host","selfProps","kids","hasMounted","hostNodeProps","attributes","attr","setState","nextState","extend","update","observeObi","obis","obi","$onChange","renderArgs","_watchesForStyleUpdates","CSSTextToObj","host","base","noRenderResults","initialRenderer","next","willMount","willRender","results","mountPoint","raf","lifeCycle","didRender","didMount","subsequentRenderer","shouldRerender","shouldUpdate","undefined","willUpdate","didUpdate","destroyed","processing","then","_","emit","detail","from","options","dispatchEvent","CustomEvent","bubbles","composed","fn","connectedCallback","observe","disconnectedCallback","isConnected","willUnmount","attributeChangedCallback","attrToProp","propTypes","prototype","observedAttr","Object","keys","prop","propToAttr","schema","def","get","set","nextValue","error","formatType","reflect","Boolean","self","x","component","config","webComponentVisibility","isComponent","CSSStyleSheet","customElements","define"],"mappings":"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"}