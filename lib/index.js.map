{"version":3,"file":"index.js","sources":["../src/utils.js","../src/vdom.js","../src/xelement.js"],"sourcesContent":["let d = document,\n    createElement = (elem) => d.createElement(elem),\n    appendChild = (node, child) => node.appendChild(child),\n    createTextNode = (text) => d.createTextNode(text),\n    toLowerCase = (toLower) => toLower.toLowerCase(),\n    toUpperCase = (toUpper) => toUpper.toUpperCase(),\n    /**\n     * creates a single style sheet. returns a function to update the same sheet\n     * @param {node|| null} mount - pass the node to mount the style element to defaults to document head\n     * @returns {function} for adding styles to the same stylesheet\n     */\n    styleSheet = (mount) => {\n        let style = createElement('style');\n        appendChild(style, createTextNode(\"\"));\n        appendChild(mount || d.head, style);\n        return (css) => (appendChild(style, createTextNode(css)), style);\n    },\n    globalStyles = styleSheet(),\n    webComponentVisibilityStyleSheet = styleSheet(),\n    webComponentVisibility = (tag) => webComponentVisibilityStyleSheet(`${tag} {visibility:hidden}`),\n\n\n    /**\n     * for parsing the incoming attributes into consumable props\n     * @param value\n     * @param type\n     * @returns {{error: boolean, value: *}}\n     */\n    formatType = (value, type) => {\n        type = type || String;\n        try {\n            if (type == Boolean) value = [true, 1, \"\", \"1\", \"true\"].includes(value);\n            else if (typeof value == \"string\") {\n                value = type == Number ? Number(value)\n                    : type == Object || type == Array ? JSON.parse(value) : value;\n            }\n            if ({}.toString.call(value) == `[object ${type.name}]`)\n                return {value, error: type == Number && Number.isNaN(value)};\n        } catch (e) {\n        }\n        return {value, error: true};\n    },\n\n    isCustomElement = (el, isAttr) => {\n        if (!el.getAttribute || !el.localName) return false;\n        isAttr = el.getAttribute('is');\n        return el.localName.includes('-') || isAttr && isAttr.includes('-');\n    },\n    /**\n     * will set or remove the attribute based on the truthyness of the value.\n     * if the type of value is object or array and the node is a custom element, it will json stringify the value\n     * @param node\n     * @param attr\n     * @param value\n     */\n    updateAttribute = (node, attr, value) => {\n        (value === null || value === false)\n            ? node.removeAttribute(attr)\n            : node.setAttribute(attr, isCustomElement(node) && (isObj(value) || isArray(value)) ? JSON.stringify(value) : value);\n    },\n\n\n    propToAttr = (prop) => toLowerCase(prop.replace(/([A-Z])/g, \"-$1\")),\n    attrToProp = (attr) => attr.replace(/-(\\w)/g, (all, letter) => toUpperCase(letter)),\n\n\n\n\n    isArray = Array.isArray,\n    isObj = (thing) => Object.prototype.toString.call(thing) === '[object Object]',\n    isFunc = (thing) => typeof thing === 'function',\n    isString = (thing) => typeof thing === 'string',\n    addListener = (to, ev, cb) => to.addEventListener(ev, cb),\n    removeListener = (from, ev, cb) => from.removeEventListener(ev, cb),\n    def = (obj, prop, handlers) => Object.defineProperty(obj, prop, handlers),\n    extend = (obj, props) => {\n        for (let i in props) obj[i] = props[i];\n        return obj\n    },\n    propsChanged = (a, b) => {\n        a = a || {};\n        b = b || {};\n        for (let i in a) if (!(i in b)) return true\n        for (let i in b) if (a[i] !== b[i]) return true\n        return false\n    },\n    objectIsEmpty = obj => Object.keys(obj || {}).length === 0,\n    // CSSTextToObj = cssText => {\n    //     var style = {},\n    //         cssToJs = s => s.startsWith('-') ? s : s.replace(/\\W+\\w/g, match => toUpperCase(match.slice(-1))),\n    //         properties = cssText.split(\";\").map(o => o.split(\":\").map(x => x && x.trim()));\n    //     for (var [property, value] of properties){\n    //         let prop = cssToJs(property);\n    //         if(prop)style[prop] = value;\n    //     }\n    //     return style\n    // },\n    TEST_ENV = process.env.NODE_ENV === 'test',\n    COMPONENT_VISIBLE_CLASSNAME = '___';\n\n\nwebComponentVisibilityStyleSheet(` .${COMPONENT_VISIBLE_CLASSNAME} {visibility: inherit;}`, true);\n\nexport {\n    toLowerCase,\n    createElement,\n    createTextNode,\n    appendChild,\n    styleSheet,\n    globalStyles,\n    webComponentVisibility,\n    formatType,\n    updateAttribute,\n    propToAttr,\n    attrToProp,\n    d,\n    TEST_ENV,\n    isArray,\n    isObj,\n    isFunc,\n    isString,\n    addListener,\n    removeListener,\n    def,\n    extend,\n    propsChanged,\n    objectIsEmpty,\n    // CSSTextToObj,\n    COMPONENT_VISIBLE_CLASSNAME\n};\n\n\n/*\nfunction CSSTextToObj(cssText) {\n    var cssTxt = cssText.replace(/\\/\\*(.|\\s)*?\\*\\//g, \" \").replace(/\\s+/g, \" \");\n    var style = {},\n        [,ruleName,rule] = cssTxt.match(/ ?(.*?) ?{([^}]*)}/)||[,,cssTxt];\n\n    var cssToJs = s => s.replace(/\\W+\\w/g, match => match.slice(-1).toUpperCase());\n\n    var properties = rule.split(\";\").map(o => o.split(\":\").map(x => x && x.trim()));\n\n    for (var [property, value] of properties) style[cssToJs(property)] = value;\n    return {cssText, ruleName, style};\n}\n\n\n\n    addDash = attr => {\n        while (attr.indexOf('-') > 0) { // - is in the attribute name, but is not the first character either\n            var afterDash = attr.substring(attr.indexOf('-') + 1)\n            afterDash = afterDash.substring(0, 1).toUpperCase() + afterDash.substring(1)\n            attr = attr.substring(0, attr.indexOf('-')) + afterDash\n        }\n        return attr\n    },\n    cssStringToObj = (str) => {\n        let _out = {};\n        str = str || '';\n        str.split(';').forEach(string => {\n            if (string !== '') {\n                var attr = string.split(':');\n                let attrName;\n                if (attr.length > 2) {\n                    attrName = attr.shift();\n                    attrName = addDash(attrName);\n                    _out[attrName] = attr.join(':')\n                } else {\n                    attrName = addDash(attr[0]);\n                    _out[attrName] = attr[1]\n                }\n            }\n        });\n        return _out;\n    };\n\n */","import {\n    d,\n    updateAttribute,\n    appendChild,\n    createElement,\n    createTextNode,\n    isFunc,\n    isObj,\n    isString,\n    isArray,\n    removeListener,\n    addListener,\n    objectIsEmpty,\n    toLowerCase,\n    COMPONENT_VISIBLE_CLASSNAME\n} from \"./utils\";\n\n// modified version of https://github.com/jorgebucaran/superfine\n\nvar removeChild = (parent, child) => parent.removeChild(child),\n    insertBefore = (parent, node, targetNode) => parent.insertBefore(node, targetNode),\n    RECYCLED_NODE = 1,\n    TEXT_NODE = 3,\n    EMPTY_OBJ = {},\n    EMPTY_ARR = [],\n    map = EMPTY_ARR.map,\n    NULL = null,\n\n    //fragment type for host node\n    HOST_TYPE = '#document-fragment',\n\n    Fragment = (props, children) => children,\n\n    merge = (a, b, out) => {\n        out = {};\n        for (var k in a) out[k] = a[k];\n        for (var k in b) out[k] = b[k];\n        return out\n    },\n\n    listener = function (event) {\n        this.handlers[event.type](event)\n    },\n\n    remHandle = node => {\n        if (!objectIsEmpty(node.handlers)) {\n            for (let k in node.handlers) {\n                removeListener(node, k, listener);\n                delete node.handlers[k]\n            }\n        }\n    },\n    /* used inside web component disconnect callback*/\n    removeHandlers = dom => {\n        remHandle(dom);\n        [].concat(...dom.childNodes).forEach(child => {\n            remHandle(child)\n            removeHandlers(child);\n        });\n    },\n\n    /* ------------ preact's style property */\n\n    IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i,\n\n    setStyle = (style, key, value) => {\n        key[0] === '-' ? style.setProperty(key, value) :\n            style[key] = typeof value === 'number' && IS_NON_DIMENSIONAL.test(key) === false ? value + 'px' : value;\n    },\n    styleNode = (dom, value, oldValue, _s) => {\n        _s = dom.style;\n        if (isString(value)) return _s.cssText = value;\n        if (isString(oldValue)) (_s.cssText = '', oldValue = NULL);\n        if (oldValue) for (let i in oldValue) if (!(value && i in value)) setStyle(_s, i, '');\n        if (value) for (let i in value) if (!oldValue || value[i] !== oldValue[i]) setStyle(_s, i, value[i]);\n    },\n\n    /* ------------ */\n\n    // i like how stencil has this built in so i figured id try to include it here\n    // optionally pass objects to className for easy conditional classes ex: className={{activeClassName: someBooleanVariable}}\n    cnObj = (obj, out) => {\n        out = \"\";\n        for (let k in obj) if (obj[k]) out += (out && \" \") + k;\n        return out;\n    },\n\n    // split the classNames up into an array and filter them\n    parseClassList = (value) => (!value) ? [] : value.split(/\\s+/).filter(c => c),\n\n    updateClassList = (node, value, action) =>\n        parseClassList(isObj(value) ? cnObj(value) : value).forEach(cls => {\n            COMPONENT_VISIBLE_CLASSNAME !== cls && node.classList[action](cls)\n        }),\n\n\n    patchProperty = (node, key, oldValue, newValue, isSvg) => {\n        if (key === \"key\") {\n        } else if (key.startsWith('on') && !(key in node)) {\n            /*\n                referencing stencil's set accessor functionality for many kinds of 'on'-event names\n                cuz \"custom\" event names defined by the user within web components may also start with 'on' like onMyCustomEvent\n                https://github.com/ionic-team/stencil/blob/master/src/runtime/vdom/set-accessor.ts\n             */\n            let eventType = (toLowerCase(key) in node)\n                ? toLowerCase(key.slice(2))\n                : toLowerCase(key[2]) + key.substring(3);\n            if (newValue) {\n                if (!oldValue) addListener(node, eventType, listener);\n                (node.handlers || (node.handlers = {}))[eventType] = newValue\n            } else removeListener(node, eventType, listener)\n\n        } else if (key === 'ref') isFunc(newValue) ? newValue(node) : newValue = node;\n        else if (key === 'style') styleNode(node, newValue, oldValue);\n        else if (key === 'className' || key === 'class') {\n            updateClassList(node, oldValue, 'remove');\n            updateClassList(node, newValue, 'add');\n            /*\n               In order to prevent initial style flashing/reflow of undefined web components\n               a style tag that is embedded in the html contains a class for all the custom element tags\n               which sets them to visibility hidden initially. Once the web component has rendered\n               it adds a class to its own classList to make it visibility inherit.\n               The following actually works great for avoiding the already defined class names that exist\n               on the component or defined by other means / internally or by some other component.\n            */\n        } else if (!isSvg && key !== \"list\" && (key in node)) node[key] = newValue == NULL ? \"\" : newValue;\n        else updateAttribute(node, key, newValue)\n    },\n\n    createNode = (vnode, isSvg) => {\n        var node = vnode.type === TEXT_NODE\n            ? createTextNode(vnode.name)\n            : (isSvg = isSvg || vnode.name === \"svg\")\n                ? d.createElementNS(\"http://www.w3.org/2000/svg\", vnode.name)\n\n                /*\n                    implements the use of a document fragment as a pseudo host element\n                    * works with the root element in a web component\n                    return(\n                        <Host> // uses #document-fragment as the h.name\n                            <my-element/>\n                            <my-box/>\n                        </Host>\n                     )\n                */\n                : (vnode.name === HOST_TYPE)\n                    ? d.createDocumentFragment()\n                    : createElement(vnode.name),\n\n            props = vnode.props;\n\n        for (var k in props) patchProperty(node, k, NULL, props[k], isSvg);\n        for (var i = 0, len = vnode.children.length; i < len; i++) appendChild(node, createNode(vnode.children[i], isSvg));\n        return (vnode.node = node)\n    },\n\n    getKey = (vnode) => vnode == NULL ? NULL : vnode.key,\n    /*\n       Looked at Atomico's code (which uses vdom in web components) and noticed the destroy method\n       on the web component base component. Since its the shadow dom, it may be possible that the child\n       nodes aren't being looked over???? checked the handlers and they were'nt being removed so i added\n       this to clean things up.\n     */\n    destroy = (dom) => {\n        removeHandlers(dom);\n        dom.destroy && dom.destroy(dom);\n        return dom;\n    },\n\n    patchNode = (parent, node, oldVNode, newVNode, isSvg) => {\n\n\n        if (oldVNode === newVNode) {\n        } else if (\n            oldVNode != NULL &&\n            oldVNode.type === TEXT_NODE &&\n            newVNode.type === TEXT_NODE\n        ) {\n            if (oldVNode.name !== newVNode.name) node.nodeValue = newVNode.name\n        } else if (oldVNode == NULL || oldVNode.name !== newVNode.name) {\n            node = insertBefore(parent, createNode(newVNode, isSvg), node)\n            if (oldVNode != NULL) removeChild(parent, destroy(oldVNode.node))\n        } else {\n            var tmpVKid,\n                oldVKid,\n                oldKey,\n                newKey,\n                oldVProps = oldVNode.props,\n                newVProps = newVNode.props,\n                oldVKids = oldVNode.children,\n                newVKids = newVNode.children,\n                oldHead = 0,\n                newHead = 0,\n                oldTail = oldVKids.length - 1,\n                newTail = newVKids.length - 1;\n            isSvg = isSvg || newVNode.name === \"svg\";\n\n            for (var key in merge(oldVProps, newVProps)) {\n                var _old = oldVProps[key], _new = newVProps[key];\n\n                if ((['value', 'selected', 'checked'].includes(key) ? node[key] : _old) !== _new) {\n                    patchProperty(node, key, _old, _new, isSvg)\n                }\n            }\n\n            while (newHead <= newTail && oldHead <= oldTail) {\n                if (\n                    (oldKey = getKey(oldVKids[oldHead])) == NULL ||\n                    oldKey !== getKey(newVKids[newHead])\n                ) {\n                    break\n                }\n\n                patchNode(\n                    node,\n                    oldVKids[oldHead].node,\n                    oldVKids[oldHead++],\n                    newVKids[newHead++],\n                    isSvg\n                )\n            }\n\n            while (newHead <= newTail && oldHead <= oldTail) {\n                if (\n                    (oldKey = getKey(oldVKids[oldTail])) == NULL ||\n                    oldKey !== getKey(newVKids[newTail])\n                ) {\n                    break\n                }\n\n                patchNode(\n                    node,\n                    oldVKids[oldTail].node,\n                    oldVKids[oldTail--],\n                    newVKids[newTail--],\n                    isSvg\n                )\n            }\n\n            if (oldHead > oldTail) {\n                while (newHead <= newTail) {\n                    insertBefore(node,\n                        createNode(newVKids[newHead++], isSvg),\n                        (oldVKid = oldVKids[oldHead]) && oldVKid.node\n                    )\n                }\n            } else if (newHead > newTail) {\n                while (oldHead <= oldTail) {\n                    removeChild(node, destroy(oldVKids[oldHead++].node))\n                }\n            } else {\n                for (var i = oldHead, keyed = {}, newKeyed = {}; i <= oldTail; i++) {\n                    if ((oldKey = oldVKids[i].key) != NULL) {\n                        keyed[oldKey] = oldVKids[i]\n                    }\n                }\n\n                while (newHead <= newTail) {\n                    oldKey = getKey((oldVKid = oldVKids[oldHead]))\n                    newKey = getKey(newVKids[newHead])\n\n                    if (\n                        newKeyed[oldKey] ||\n                        (newKey != NULL && newKey === getKey(oldVKids[oldHead + 1]))\n                    ) {\n                        if (oldKey == NULL) removeChild(node, destroy(oldVKid.node))\n                        oldHead++\n                        continue\n                    }\n\n                    if (newKey == NULL || oldVNode.type === RECYCLED_NODE) {\n                        if (oldKey == NULL) {\n                            patchNode(\n                                node,\n                                oldVKid && oldVKid.node,\n                                oldVKid,\n                                newVKids[newHead],\n                                isSvg\n                            )\n                            newHead++\n                        }\n                        oldHead++\n                    } else {\n                        if (oldKey === newKey) {\n                            patchNode(node, oldVKid.node, oldVKid, newVKids[newHead], isSvg)\n                            newKeyed[newKey] = true\n                            oldHead++\n                        } else {\n                            if ((tmpVKid = keyed[newKey]) != NULL) {\n                                patchNode(\n                                    node,\n                                    insertBefore(node, tmpVKid.node, oldVKid && oldVKid.node),\n                                    tmpVKid,\n                                    newVKids[newHead],\n                                    isSvg\n                                )\n                                newKeyed[newKey] = true\n                            } else {\n                                patchNode(\n                                    node,\n                                    oldVKid && oldVKid.node,\n                                    NULL,\n                                    newVKids[newHead],\n                                    isSvg\n                                )\n                            }\n                        }\n                        newHead++\n                    }\n                }\n\n                while (oldHead <= oldTail)\n                    if (getKey((oldVKid = oldVKids[oldHead++])) == NULL) removeChild(node, destroy(oldVKid.node));\n\n                for (var i in keyed) if (newKeyed[i] == NULL) removeChild(node, destroy(keyed[i].node))\n            }\n        }\n        return (newVNode.node = node)\n    },\n    createVNode = (name, props, children, node, key, type) => ({name, props, children, node, type, key}),\n    createTextVNode = (value, node) => createVNode(value, EMPTY_OBJ, EMPTY_ARR, node, NULL, TEXT_NODE),\n    recycleNode = (node) =>\n        node.nodeType === TEXT_NODE\n            ? createTextVNode(node.nodeValue, node)\n            : createVNode(\n            toLowerCase(node.nodeName),\n            EMPTY_OBJ,\n            map.call(node.childNodes, recycleNode),\n            node,\n            NULL,\n            RECYCLED_NODE\n            ),\n\n    patch = (node, vdom) => (\n        ((node = patchNode(\n            node.parentNode,\n            node,\n            node.vdom || recycleNode(node),\n            vdom\n        )).vdom = vdom),\n            node\n    ),\n    h = function (name, props) {\n        for (var vnode, rest = [], children = [], i = arguments.length; i-- > 2;) rest.push(arguments[i]);\n        while (rest.length > 0) {\n            if (isArray((vnode = rest.pop()))) {\n                for (var i = vnode.length; i-- > 0;) rest.push(vnode[i])\n            } else if (vnode === false || vnode === true || vnode == NULL) {\n            } else children.push(isObj(vnode) ? vnode : createTextVNode(vnode));\n        }\n        props = props || EMPTY_OBJ\n        return isFunc(name)\n            ? name(props, children)\n            : createVNode(name, props, children, NULL, props.key)\n    };\n\nexport {patch, h, Fragment, removeHandlers, HOST_TYPE, patchProperty, merge}\n\n","import {\n    formatType,\n    updateAttribute,\n    propToAttr,\n    attrToProp,\n    webComponentVisibility,\n    createElement,\n    appendChild,\n    TEST_ENV,\n    def, extend, isFunc,\n    COMPONENT_VISIBLE_CLASSNAME\n} from \"../src/utils\";\n\nimport {h, patch, removeHandlers, HOST_TYPE, patchProperty, merge} from \"./vdom\";\n\n\nlet PROPS = Symbol(),\n    // PROPS = 'props',\n    IGNORE_ATTR = Symbol(),\n    context = {},\n    adoptedCSS = \"adoptedStyleSheets\" in document;\n\n// let shady = window.ShadyCSS;\n// --- yeah, prop not gonna even bother with internet explorer...\n// styles can't be dynamically updated in the render func, the docs say to use custom properties only\n\n/* inspiration driven by superfine, atomico, stencil, preact and open-wc */\n\n\nclass Xelement extends HTMLElement {\n\n    context = context;\n\n    _unsubs = [];\n\n    state = {};\n\n    constructor() {\n        super();\n        this._root = this.attachShadow({mode: 'open'});//  (this.shadowRoot || this) maybe eventually include the option to not use shadowDom\n        this[PROPS] = {};\n        this.render = this.render.bind(this);\n        this._mounted = new Promise(mount => (this._mount = mount));\n        this.update();\n        let {_initAttrs, _rootSheet} = this.constructor;\n        let length = _initAttrs.length;\n        while (length--) _initAttrs[length](this);\n\n        if (adoptedCSS) this._root.adoptedStyleSheets = [_rootSheet];\n\n        this.CSS = ({updatable, css}, children) => {\n            let cssText = css || children;\n            if (!cssText) return null;\n            if (!adoptedCSS) return <style>{cssText}</style>;\n            else if (_rootSheet.cssRules.length === 0) _rootSheet.replaceSync(cssText);\n            return null;\n        }\n    }\n\n    Host = (selfProps, children) => {\n        this._usingFrag = true;\n        let hostNodeProps = {}, i = 0, a = this.attributes;\n        for (i = a.length; i--;) {\n            let attr = a[i].name;\n            hostNodeProps[attr === 'class' ? 'className' : attr] = a[i].value;\n        }\n        // this._mounted.then(() => {\n        for (let key in selfProps) {\n            patchProperty(this, key, hostNodeProps[key], selfProps[key]);\n        }\n        // });\n        return h(HOST_TYPE, {}, children);\n    };\n\n    connectedCallback() {\n        if (this._has_mounted) return;\n        this.state.$onChange && this._unsubs.push(this.state.$onChange(this.update));\n        this.observe && this.observeObi(this.observe);\n        this._mount();\n    }\n\n    setState = nextState => {\n        extend(this.state, isFunc(nextState) ? nextState(this.state) : nextState || {});\n        this.update();\n    };\n\n    observeObi = (...obis) =>\n        obis.forEach(obi => obi.$onChange && this._unsubs.push(obi.$onChange(this.update)));\n\n    update = () => {\n        if (!this._process) {\n            this._process = this._mounted.then(_ => {\n                !this._has_mounted ? this._initialRender() : this._subsequentRender();\n                this._process = false;\n            });\n        }\n        return this._process;\n    };\n\n    _renderArgs = () => [extend({Host: this.Host, CSS: this.CSS, host: this}, this[PROPS]), this.state, this.context];\n\n    /*adding visibility inherit next tick after render will prevent flash of un-styled content. (inspired by stencil.js)\n     Removing this functionality during testing makes life easier  */\n    _initialRender = () => {\n        let next = this._renderArgs();\n        this.willRender(...next);\n        let results = this.render(...next);\n        let mountPoint = createElement(this._usingFrag ? 'template' : results.name);\n        appendChild(this._root, mountPoint);\n        this._base = patch(this._usingFrag ? this._root : mountPoint, results);\n        this.didRender(...next);\n        this._has_mounted = true;\n        let postInitial = () => {\n            this._unsubs.push(this.lifeCycle());\n            !TEST_ENV && this.classList.add(COMPONENT_VISIBLE_CLASSNAME);\n        };\n        !TEST_ENV ? requestAnimationFrame(postInitial) : postInitial();\n    };\n\n    _subsequentRender = () => {\n        let next = this._renderArgs();\n        let shouldRerender = this.willRender();// returning a falsy value other than undefined will prevent rerender\n        if (!shouldRerender && shouldRerender !== undefined) return;\n        patch(this._usingFrag ? this._root : this._base, this.render(...next));\n        this.didRender(...next);\n    };\n\n    emit = (name, detail, from) => (from || this).dispatchEvent(\n        new CustomEvent(name, {detail, bubbles: true, composed: true})\n    );\n\n\n    attributeChangedCallback(attr, oldValue, newValue) {\n        if (attr === this[IGNORE_ATTR] || oldValue === newValue) return;\n        this[attrToProp(attr)] = newValue;\n    }\n\n    /* inspired by atomico  */\n    static get observedAttributes() {\n        let {propTypes, prototype} = this;\n        this._initAttrs = [];\n        if (!propTypes) return [];\n        return Object.keys(propTypes).map(prop => {\n            let attr = propToAttr(prop),\n                schema = propTypes[prop].name ? {type: propTypes[prop]} : propTypes[prop];\n            if (!(prop in prototype)) {\n                def(prototype, prop, {\n                    get() {\n                        return this[PROPS][prop]\n                    },\n                    set(nextValue) {\n                        let {value, error} = formatType(nextValue, schema.type);\n                        if (error && value != null) throw `[${prop}] must be type [${schema.type.name}]`;\n                        if (value === this[PROPS][prop]) return;\n                        if (schema.reflect) {\n                            this._mounted.then(() => {\n                                this[IGNORE_ATTR] = attr;\n                                updateAttribute(this, attr, schema.type === Boolean && !value ? null : value);\n                                this[IGNORE_ATTR] = false;\n                            });\n                        }\n                        this[PROPS][prop] = value;\n                        this.update();\n                    }\n                });\n            }\n            schema.value && this._initAttrs.push(self => (self[prop] = schema.value));\n            return attr;\n        });\n    };\n\n    lifeCycle() {\n    }\n\n    willRender() {\n    }\n\n    render() {\n    }\n\n    didRender() {\n    }\n\n    disconnectedCallback() {\n        !this.isConnected && !this._destroyed && this.destroy();\n    }\n\n    destroy = (dom) => {\n        if (!this._destroyed) {\n            dom && removeHandlers(dom);\n            this._unsubs.forEach(fn => isFunc(fn) && fn());\n            this._destroyed = true;\n        }\n    };\n}\n\n\nconst element = (tag, component, propTypes) => {\n\n        webComponentVisibility(tag);\n\n        const rootSheet = adoptedCSS && new CSSStyleSheet(),\n            isXelment = component.prototype instanceof Xelement;\n        if (isXelment) component._rootSheet = rootSheet;\n\n        customElements.define(tag,\n            isXelment ? component : class extends Xelement {\n                static propTypes = propTypes;\n                static _rootSheet = rootSheet;\n                render = component\n            }\n        );\n        return (props, children) => h(tag, props, children);\n    },\n\n    x = (tag, component, propTypes) =>\n        element('x-' + tag, component, propTypes);\n\nexport {Xelement, x, element, context};\n\n\n//\n// if(key === 'style'){\n//     let hostNodeStyleObj = CSSTextToObj(this.style.cssText);\n//     let selfStyleObj = isObj(selfProps.style) ? selfProps.style : CSSTextToObj(selfProps.style);\n//\n//     console.log('host node style obj', hostNodeStyleObj);\n//     console.log('selfStyleOjb', selfStyleObj)\n//     newValue = extend(hostNodeStyleObj, selfStyleObj);\n//     oldValue = hostNodeStyleObj;\n//     console.log('merged style', newValue)\n// }\n// console.log('old value', oldValue);\n// console.log('new value', newValue)"],"names":["d","document","createElement","elem","appendChild","node","child","createTextNode","text","toLowerCase","toLower","styleSheet","mount","style","head","css","globalStyles","webComponentVisibilityStyleSheet","formatType","value","type","String","Boolean","includes","Number","Object","Array","JSON","parse","toString","call","name","error","isNaN","e","updateAttribute","attr","removeAttribute","setAttribute","el","isAttr","getAttribute","localName","isCustomElement","isObj","isArray","stringify","propToAttr","prop","replace","attrToProp","all","letter","toUpper","toUpperCase","thing","prototype","isFunc","isString","removeListener","from","ev","cb","removeEventListener","def","obj","handlers","defineProperty","extend","props","i","COMPONENT_VISIBLE_CLASSNAME","removeChild","parent","insertBefore","targetNode","EMPTY_OBJ","EMPTY_ARR","map","HOST_TYPE","Fragment","children","listener","event","remHandle","keys","length","objectIsEmpty","k","removeHandlers","dom","concat","childNodes","forEach","IS_NON_DIMENSIONAL","setStyle","key","setProperty","test","updateClassList","action","split","filter","c","parseClassList","out","cnObj","cls","classList","patchProperty","oldValue","newValue","isSvg","startsWith","_s","cssText","styleNode","eventType","slice","substring","to","addEventListener","addListener","createNode","vnode","createElementNS","createDocumentFragment","len","getKey","destroy","patchNode","oldVNode","newVNode","nodeValue","tmpVKid","oldVKid","oldKey","newKey","oldVProps","newVProps","oldVKids","newVKids","oldHead","newHead","oldTail","newTail","a","b","merge","_old","_new","keyed","newKeyed","createVNode","createTextVNode","recycleNode","nodeType","nodeName","patch","vdom","parentNode","h","rest","arguments","push","pop","PROPS","Symbol","IGNORE_ATTR","context","adoptedCSS","Xelement","HTMLElement","constructor","_unsubs","state","Host","selfProps","_usingFrag","hostNodeProps","this","attributes","setState","nextState","update","observeObi","obis","obi","$onChange","_process","_mounted","then","_","_has_mounted","_subsequentRender","_initialRender","_renderArgs","CSS","host","next","willRender","results","render","mountPoint","_root","_base","didRender","requestAnimationFrame","lifeCycle","add","shouldRerender","undefined","emit","detail","dispatchEvent","CustomEvent","bubbles","composed","_destroyed","fn","attachShadow","mode","bind","Promise","_mount","j","_initAttrs","C","_rootSheet","adoptedStyleSheets","updatable","cssRules","replaceSync","connectedCallback","observe","attributeChangedCallback","propTypes","schema","get","set","nextValue","reflect","self","disconnectedCallback","isConnected","element","tag","component","webComponentVisibility","rootSheet","CSSStyleSheet","isXelment","customElements","define","x"],"mappings":"IAAIA,EAAIC,SACJC,EAAiBC,GAASH,EAAEE,cAAcC,GAC1CC,EAAc,CAACC,EAAMC,IAAUD,EAAKD,YAAYE,GAChDC,EAAkBC,GAASR,EAAEO,eAAeC,GAC5CC,EAAeC,GAAYA,EAAQD,cAOnCE,EAAcC,QACNC,EAAQX,EAAc,gBAC1BE,EAAYS,EAAON,EAAe,KAClCH,EAAYQ,GAASZ,EAAEc,KAAMD,GACrBE,IAASX,EAAYS,EAAON,EAAeQ,IAAOF,IAE9DG,EAAeL,IACfM,EAAmCN,IAUnCO,EAAa,CAACC,EAAOC,KACjBA,EAAOA,GAAQC,cAEPD,GAAQE,QAASH,EAAQ,EAAC,EAAM,EAAG,GAAI,IAAK,QAAQI,SAASJ,GACxC,iBAATA,IACZA,EAAQC,GAAQI,OAASA,OAAOL,GAC1BC,GAAQK,QAAUL,GAAQM,MAAQC,KAAKC,MAAMT,GAASA,GAE5D,GAAGU,SAASC,KAAKX,eAAqBC,EAAKW,QAC3C,MAAO,CAACZ,MAAAA,EAAOa,MAAOZ,GAAQI,QAAUA,OAAOS,MAAMd,IAC3D,MAAOe,UAEF,CAACf,MAAAA,EAAOa,OAAO,IAe1BG,EAAkB,CAAC9B,EAAM+B,EAAMjB,KAChB,OAAVA,IAA4B,IAAVA,EACbd,EAAKgC,gBAAgBD,GACrB/B,EAAKiC,aAAaF,EAfV,EAACG,EAAIC,OACdD,EAAGE,eAAiBF,EAAGG,aAC5BF,EAASD,EAAGE,aAAa,MAClBF,EAAGG,UAAUnB,SAAS,MAAQiB,GAAUA,EAAOjB,SAAS,MAYjCoB,CAAgBtC,KAAUuC,EAAMzB,IAAU0B,EAAQ1B,IAAUQ,KAAKmB,UAAU3B,GAASA,IAItH4B,EAAcC,GAASvC,EAAYuC,EAAKC,QAAQ,WAAY,QAC5DC,EAAcd,GAASA,EAAKa,QAAQ,SAAU,CAACE,EAAKC,IA1DrCC,CAAAA,GAAYA,EAAQC,cA0D4BA,CAAYF,IAK3EP,EAAUnB,MAAMmB,QAChBD,EAASW,GAAoD,oBAA1C9B,OAAO+B,UAAU3B,SAASC,KAAKyB,GAClDE,EAAUF,GAA2B,mBAAVA,EAC3BG,EAAYH,GAA2B,iBAAVA,EAE7BI,EAAiB,CAACC,EAAMC,EAAIC,IAAOF,EAAKG,oBAAoBF,EAAIC,GAChEE,EAAM,CAACC,EAAKjB,EAAMkB,IAAazC,OAAO0C,eAAeF,EAAKjB,EAAMkB,GAChEE,EAAS,CAACH,EAAKI,SACN,IAAIC,KAAKD,EAAOJ,EAAIK,GAAKD,EAAMC,UAC7BL,GAUXM,EAW8B,MAGlCtD,OAAsCsD,4BAAsD,OClFxFC,EAAc,CAACC,EAAQnE,IAAUmE,EAAOD,YAAYlE,GACpDoE,EAAe,CAACD,EAAQpE,EAAMsE,IAAeF,EAAOC,aAAarE,EAAMsE,GAGvEC,EAAY,GACZC,EAAY,GACZC,EAAMD,EAAUC,IAIhBC,EAAY,qBAEZC,EAAW,CAACX,EAAOY,IAAaA,EAShCC,EAAW,SAAUC,QACZjB,SAASiB,EAAM/D,MAAM+D,IAG9BC,EAAY/E,QD0CI4D,CAAAA,GAAyC,IAAlCxC,OAAO4D,KAAKpB,GAAO,IAAIqB,OCzCrCC,CAAclF,EAAK6D,cACf,IAAIsB,KAAKnF,EAAK6D,SACfP,EAAetD,EAAMmF,EAAGN,UACjB7E,EAAK6D,SAASsB,IAKjCC,EAAiBC,IACbN,EAAUM,MACPC,UAAUD,EAAIE,YAAYC,QAAQvF,IACjC8E,EAAU9E,GACVmF,EAAenF,MAMvBwF,EAAqB,kEAErBC,EAAW,CAAClF,EAAOmF,EAAK7E,KACT,MAAX6E,EAAI,GAAanF,EAAMoF,YAAYD,EAAK7E,GACpCN,EAAMmF,GAAwB,iBAAV7E,IAAuD,IAAjC2E,EAAmBI,KAAKF,GAAiB7E,EAAQ,KAAOA,GAuB1GgF,EAAkB,CAAC9F,EAAMc,EAAOiF,IAFdjF,CAAAA,GAAYA,EAAcA,EAAMkF,MAAM,OAAOC,OAAOC,GAAKA,GAApC,GAGnCC,CAAe5D,EAAMzB,GAVjB,EAAC8C,EAAKwC,KACVA,EAAM,OACD,IAAIjB,KAAKvB,EAASA,EAAIuB,KAAIiB,IAAQA,GAAO,KAAOjB,UAC9CiB,GAOuBC,CAAMvF,GAASA,GAAO0E,QAAQc,IACxDpC,IAAgCoC,GAAOtG,EAAKuG,UAAUR,GAAQO,KAItEE,EAAgB,CAACxG,EAAM2F,EAAKc,EAAUC,EAAUC,QAChC,QAARhB,QACG,IAAIA,EAAIiB,WAAW,OAAWjB,KAAO3F,EAczB,QAAR2F,EAAevC,EAAOsD,GAAYA,EAAS1G,GAAQ0G,EAAW1G,EACxD,UAAR2F,EA5CD,EAACN,EAAKvE,EAAO2F,EAAUI,QAC/BA,EA2CoC7G,EA3C3BQ,MACL6C,EAASvC,GAAQ,OAAO+F,EAAGC,QAAUhG,KACrCuC,EAASoD,KAAYI,EAAGC,QAAU,GAAIL,EA9CvC,MA+CCA,EAAU,IAAK,IAAIxC,KAAKwC,EAAgB3F,GAASmD,KAAKnD,GAAQ4E,EAASmB,EAAI5C,EAAG,OAC9EnD,EAAO,IAAK,IAAImD,KAAKnD,EAAY2F,GAAY3F,EAAMmD,KAAOwC,EAASxC,IAAIyB,EAASmB,EAAI5C,EAAGnD,EAAMmD,KAuCvE8C,CAAU/G,EAAM0G,EAAUD,GACnC,cAARd,GAA+B,UAARA,GAC5BG,EAAgB9F,EAAMyG,EAAU,UAChCX,EAAgB9F,EAAM0G,EAAU,SASxBC,GAAiB,SAARhB,GAAmBA,KAAO3F,EAAOA,EAAK2F,GAnGxD,MAmG+De,EAAmB,GAAKA,EACrF5E,EAAgB9B,EAAM2F,EAAKe,OA5BmB,KAM3CM,EAAa5G,EAAYuF,KAAQ3F,EAC/BI,EAAYuF,EAAIsB,MAAM,IACtB7G,EAAYuF,EAAI,IAAMA,EAAIuB,UAAU,GACtCR,GACKD,GDpCH,EAACU,EAAI3D,EAAIC,IAAO0D,EAAGC,iBAAiB5D,EAAIC,GCoC3B4D,CAAYrH,EAAMgH,EAAWnC,IAC3C7E,EAAK6D,WAAa7D,EAAK6D,SAAW,KAAKmD,GAAaN,GAClDpD,EAAetD,EAAMgH,EAAWnC,KAmB/CyC,EAAa,CAACC,EAAOZ,SACb3G,EA5GI,IA4GGuH,EAAMxG,KACXb,EAAeqH,EAAM7F,OACpBiF,EAAQA,GAAwB,QAAfY,EAAM7F,MACpB/B,EAAE6H,gBAAgB,6BAA8BD,EAAM7F,MAYrD6F,EAAM7F,OAASgD,EACZ/E,EAAE8H,yBACF5H,EAAc0H,EAAM7F,MAE9BsC,EAAQuD,EAAMvD,UAEb,IAAImB,KAAKnB,EAAOwC,EAAcxG,EAAMmF,EA7HtC,KA6H+CnB,EAAMmB,GAAIwB,OACvD,IAAI1C,EAAI,EAAGyD,EAAMH,EAAM3C,SAASK,OAAQhB,EAAIyD,EAAKzD,IAAKlE,EAAYC,EAAMsH,EAAWC,EAAM3C,SAASX,GAAI0C,WACnGY,EAAMvH,KAAOA,GAGzB2H,EAAUJ,GAlIH,MAkIaA,EAlIb,KAkIoCA,EAAM5B,IAOjDiC,EAAWvC,IACPD,EAAeC,GACfA,EAAIuC,SAAWvC,EAAIuC,QAAQvC,GACpBA,GAGXwC,EAAY,CAACzD,EAAQpE,EAAM8H,EAAUC,EAAUpB,QAGvCmB,IAAaC,QACV,GAnJJ,MAoJCD,GAxJI,IAyJJA,EAAS/G,MAzJL,IA0JJgH,EAAShH,KAEL+G,EAASpG,OAASqG,EAASrG,OAAM1B,EAAKgI,UAAYD,EAASrG,WAC5D,GAzJJ,MAyJQoG,GAAoBA,EAASpG,OAASqG,EAASrG,KACtD1B,EAAOqE,EAAaD,EAAQkD,EAAWS,EAAUpB,GAAQ3G,GA1J1D,MA2JK8H,GAAkB3D,EAAYC,EAAQwD,EAAQE,EAAS9H,WACxD,KACCiI,EACAC,EACAC,EACAC,EACAC,EAAYP,EAAS9D,MACrBsE,EAAYP,EAAS/D,MACrBuE,EAAWT,EAASlD,SACpB4D,EAAWT,EAASnD,SACpB6D,EAAU,EACVC,EAAU,EACVC,EAAUJ,EAAStD,OAAS,EAC5B2D,EAAUJ,EAASvD,OAAS,MAG3B,IAAIU,KAFTgB,EAAQA,GAA2B,QAAlBoB,EAASrG,KAlK1B,EAACmH,EAAGC,EAAG1C,SAEN,IAAIjB,KADTiB,EAAM,GACQyC,EAAGzC,EAAIjB,GAAK0D,EAAE1D,OACvB,IAAIA,KAAK2D,EAAG1C,EAAIjB,GAAK2D,EAAE3D,UACrBiB,GAgKa2C,CAAMV,EAAWC,GAAY,KACrCU,EAAOX,EAAU1C,GAAMsD,EAAOX,EAAU3C,IAEvC,CAAC,QAAS,WAAY,WAAWzE,SAASyE,GAAO3F,EAAK2F,GAAOqD,KAAUC,GACxEzC,EAAcxG,EAAM2F,EAAKqD,EAAMC,EAAMtC,QAItC+B,GAAWE,GAAWH,GAAWE,GAnLzC,OAqLUR,EAASR,EAAOY,EAASE,MAC1BN,IAAWR,EAAOa,EAASE,KAK/Bb,EACI7H,EACAuI,EAASE,GAASzI,KAClBuI,EAASE,KACTD,EAASE,KACT/B,QAID+B,GAAWE,GAAWH,GAAWE,GApMzC,OAsMUR,EAASR,EAAOY,EAASI,MAC1BR,IAAWR,EAAOa,EAASI,KAK/Bf,EACI7H,EACAuI,EAASI,GAAS3I,KAClBuI,EAASI,KACTH,EAASI,KACTjC,MAIJ8B,EAAUE,OACHD,GAAWE,GACdvE,EAAarE,EACTsH,EAAWkB,EAASE,KAAY/B,IAC/BuB,EAAUK,EAASE,KAAaP,EAAQlI,WAG9C,GAAI0I,EAAUE,OACVH,GAAWE,GACdxE,EAAYnE,EAAM4H,EAAQW,EAASE,KAAWzI,WAE/C,KACE,IAAIiE,EAAIwE,EAASS,EAAQ,GAAIC,EAAW,GAAIlF,GAAK0E,EAAS1E,IAjOpE,OAkOckE,EAASI,EAAStE,GAAG0B,OACtBuD,EAAMf,GAAUI,EAAStE,SAI1ByE,GAAWE,GACdT,EAASR,EAAQO,EAAUK,EAASE,IACpCL,EAAST,EAAOa,EAASE,IAGrBS,EAAShB,IA5OtB,MA6OcC,GAAkBA,IAAWT,EAAOY,EAASE,EAAU,KA7OrE,MA+OiBN,GAAgBhE,EAAYnE,EAAM4H,EAAQM,EAAQlI,OACtDyI,KAhPb,MAoPaL,GAzPJ,IAyPsBN,EAAS/G,MApPxC,MAqPiBoH,IACAN,EACI7H,EACAkI,GAAWA,EAAQlI,KACnBkI,EACAM,EAASE,GACT/B,GAEJ+B,KAEJD,MAEIN,IAAWC,GACXP,EAAU7H,EAAMkI,EAAQlI,KAAMkI,EAASM,EAASE,GAAU/B,GAC1DwC,EAASf,IAAU,EACnBK,KApQjB,OAsQsBR,EAAUiB,EAAMd,KACjBP,EACI7H,EACAqE,EAAarE,EAAMiI,EAAQjI,KAAMkI,GAAWA,EAAQlI,MACpDiI,EACAO,EAASE,GACT/B,GAEJwC,EAASf,IAAU,GAEnBP,EACI7H,EACAkI,GAAWA,EAAQlI,KAlR5C,KAoRyBwI,EAASE,GACT/B,GAIZ+B,UAIDD,GAAWE,GA7RvB,MA8RahB,EAAQO,EAAUK,EAASE,OAAsBtE,EAAYnE,EAAM4H,EAAQM,EAAQlI,WAEtF,IAAIiE,KAAKiF,EAhSnB,MAgS8BC,EAASlF,IAAYE,EAAYnE,EAAM4H,EAAQsB,EAAMjF,GAAGjE,eAGjF+H,EAAS/H,KAAOA,GAE5BoJ,EAAc,CAAC1H,EAAMsC,EAAOY,EAAU5E,EAAM2F,EAAK5E,MAAWW,KAAAA,EAAMsC,MAAAA,EAAOY,SAAAA,EAAU5E,KAAAA,EAAMe,KAAAA,EAAM4E,IAAAA,IAC/F0D,EAAkB,CAACvI,EAAOd,IAASoJ,EAAYtI,EAAOyD,EAAWC,EAAWxE,EAtSrE,KAJK,GA2SZsJ,EAAetJ,GA3SH,IA4SRA,EAAKuJ,SACCF,EAAgBrJ,EAAKgI,UAAWhI,GAChCoJ,EACFhJ,EAAYJ,EAAKwJ,UACjBjF,EACAE,EAAIhD,KAAKzB,EAAKuF,WAAY+D,GAC1BtJ,EA9SD,KALS,GAwThByJ,EAAQ,CAACzJ,EAAM0J,MACT1J,EAAO6H,EACL7H,EAAK2J,WACL3J,EACAA,EAAK0J,MAAQJ,EAAYtJ,GACzB0J,IACDA,KAAOA,EACN1J,GAER4J,EAAI,SAAUlI,EAAMsC,OACX,IAAIuD,EAAOsC,EAAO,GAAIjF,EAAW,GAAIX,EAAI6F,UAAU7E,OAAQhB,KAAM,GAAI4F,EAAKE,KAAKD,UAAU7F,SACvF4F,EAAK5E,OAAS,MACbzC,EAAS+E,EAAQsC,EAAKG,WACb/F,EAAIsD,EAAMtC,OAAQhB,KAAM,GAAI4F,EAAKE,KAAKxC,EAAMtD,SACpC,IAAVsD,IAA6B,IAAVA,GAjU/B,MAiUiDA,GACzC3C,EAASmF,KAAKxH,EAAMgF,GAASA,EAAQ8B,EAAgB9B,WAEhEvD,EAAQA,GAASO,EACVnB,EAAO1B,GACRA,EAAKsC,EAAOY,GACZwE,EAAY1H,EAAMsC,EAAOY,EAvU5B,KAuU4CZ,EAAM2B,UCjVzDsE,EAAQC,SAERC,EAAcD,SACdE,EAAU,GACVC,EAAa,uBAAwBzK,SASzC,MAAM0K,UAAiBC,YAQnBC,2BANAJ,QAAUA,OAEVK,EAAU,QAEVC,MAAQ,QAwBRC,KAAO,CAACC,EAAWhG,UACViG,GAAa,MACdC,EAAgB,GAAI7G,EAAI,EAAG4E,EAAIkC,KAAKC,eACnC/G,EAAI4E,EAAE5D,OAAQhB,KAAM,KACjBlC,EAAO8G,EAAE5E,GAAGvC,KAChBoJ,EAAuB,UAAT/I,EAAmB,YAAcA,GAAQ8G,EAAE5E,GAAGnD,UAG3D,IAAI6E,KAAOiF,EACZpE,EAAcuE,KAAMpF,EAAKmF,EAAcnF,GAAMiF,EAAUjF,WAGpDiE,EAAElF,EAAW,GAAIE,SAU5BqG,SAAWC,IACPnH,EAAOgH,KAAKL,MAAOtH,EAAO8H,GAAaA,EAAUH,KAAKL,OAASQ,GAAa,SACvEC,eAGTC,WAAa,IAAIC,IACbA,EAAK7F,QAAQ8F,GAAOA,EAAIC,WAAaR,KAAKN,EAAQV,KAAKuB,EAAIC,UAAUR,KAAKI,eAE9EA,OAAS,KACAJ,KAAKS,SACDA,EAAWT,KAAKU,EAASC,KAAKC,IAC9BZ,KAAKa,EAAuCb,KAAKc,IAA7Bd,KAAKe,SACrBN,GAAW,KAGjBT,KAAKS,QAGhBO,EAAc,IAAM,CAAChI,EAAO,CAAC4G,KAAMI,KAAKJ,KAAMqB,IAAKjB,KAAKiB,IAAKC,KAAMlB,MAAOA,KAAKd,IAASc,KAAKL,MAAOK,KAAKX,cAIzG0B,EAAiB,SACTI,EAAOnB,KAAKgB,SACXI,cAAcD,OACfE,EAAUrB,KAAKsB,UAAUH,GACzBI,EAAazM,EAAckL,KAAKF,EAAa,WAAauB,EAAQ1K,MACtE3B,EAAYgL,KAAKwB,EAAOD,QACnBE,EAAQ/C,EAAMsB,KAAKF,EAAaE,KAAKwB,EAAQD,EAAYF,QACzDK,aAAaP,QACbN,GAAe,EAKRc,sBAJM,UACTjC,EAAQV,KAAKgB,KAAK4B,aACV5B,KAAKxE,UAAUqG,IAAI1I,WAKxC2H,EAAoB,SACZK,EAAOnB,KAAKgB,IACZc,EAAiB9B,KAAKoB,cACrBU,QAAqCC,IAAnBD,KACvBpD,EAAMsB,KAAKF,EAAaE,KAAKwB,EAAQxB,KAAKyB,EAAOzB,KAAKsB,UAAUH,SAC3DO,aAAaP,UAGtBa,KAAO,CAACrL,EAAMsL,EAAQzJ,KAAUA,GAAQwH,MAAMkC,cAC1C,IAAIC,YAAYxL,EAAM,CAACsL,OAAAA,EAAQG,SAAS,EAAMC,UAAU,UA2D5DxF,QAAWvC,IACF0F,KAAKsC,IACNhI,GAAOD,EAAeC,QACjBoF,EAAQjF,QAAQ8H,GAAMlK,EAAOkK,IAAOA,UACpCD,GAAa,SAxJjBd,EAAQxB,KAAKwC,aAAa,CAACC,KAAM,cACjCvD,GAAS,QACToC,OAAStB,KAAKsB,OAAOoB,KAAK1C,WAC1BU,EAAW,IAAIiC,QAAQnN,GAAUwK,KAAK4C,EAASpN,QAC/C4K,aACDyC,EAACC,EAADC,EAAaC,GAAchD,KAAKP,YAChCvF,EAAS4I,EAAW5I,YACjBA,KAAU4I,EAAW5I,GAAQ8F,MAEhCV,IAAYU,KAAKwB,EAAMyB,mBAAqB,CAACD,SAE5C/B,IAAM,EAAEiC,UAAAA,EAAWvN,IAAAA,GAAMkE,SACtBkC,EAAUpG,GAAOkE,SAChBkC,EACAuD,GACmC,IAA/B0D,EAAWG,SAASjJ,QAAc8I,EAAWI,YAAYrH,GAC3D,MAFiB8C,eAAQ9C,GADX,MAsB7BsH,oBACQrD,KAAKa,SACJlB,MAAMa,WAAaR,KAAKN,EAAQV,KAAKgB,KAAKL,MAAMa,UAAUR,KAAKI,cAC/DkD,SAAWtD,KAAKK,WAAWL,KAAKsD,cAChCV,KAsDTW,yBAAyBvM,EAAM0E,EAAUC,GACjC3E,IAASgJ,KAAKZ,IAAgB1D,IAAaC,SAC1C7D,EAAWd,IAAS2E,uCAKrB6H,UAACA,EAADpL,UAAYA,GAAa4H,iBACxB8C,EAAa,GACbU,EACEnN,OAAO4D,KAAKuJ,GAAW9J,IAAI9B,QAC1BZ,EAAOW,EAAWC,GAClB6L,EAASD,EAAU5L,GAAMjB,KAAO,CAACX,KAAMwN,EAAU5L,IAAS4L,EAAU5L,UAClEA,KAAQQ,GACVQ,EAAIR,EAAWR,EAAM,CACjB8L,aACW1D,KAAKd,GAAOtH,IAEvB+L,IAAIC,OACI7N,MAACA,EAADa,MAAQA,GAASd,EAAW8N,EAAWH,EAAOzN,SAC9CY,GAAkB,MAATb,EAAe,SAAU6B,oBAAuB6L,EAAOzN,KAAKW,QACrEZ,IAAUiK,KAAKd,GAAOtH,KACtB6L,EAAOI,cACFnD,EAASC,KAAK,UACVvB,GAAepI,EACpBD,EAAgBiJ,KAAMhJ,EAAMyM,EAAOzN,OAASE,SAAYH,EAAeA,EAAP,WAC3DqJ,IAAe,SAGvBF,GAAOtH,GAAQ7B,OACfqK,aAIjBqD,EAAO1N,OAASiK,KAAK8C,EAAW9D,KAAK8E,GAASA,EAAKlM,GAAQ6L,EAAO1N,OAC3DiB,IA1BY,GA8B3B4K,aAGAR,cAGAE,UAGAI,aAGAqC,wBACK/D,KAAKgE,cAAgBhE,KAAKsC,GAActC,KAAKnD,WAatD,MAAMoH,EAAU,CAACC,EAAKC,EAAWX,aFlLHU,CAAAA,GAAQrO,KAAoCqO,yBEoLlEE,CAAuBF,SAEjBG,EAAY/E,GAAc,IAAIgF,cAChCC,EAAYJ,EAAU/L,qBAAqBmH,SAC3CgF,IAAWJ,EAAUnB,EAAaqB,GAEtCG,eAAeC,OAAOP,EAClBK,EAAYJ,OAAY,cAAc5E,qCAGlC+B,OAAS6C,MAFFX,UAAYA,IACZR,EAAaqB,MAIrB,CAACpL,EAAOY,IAAagF,EAAEqF,EAAKjL,EAAOY,IAG9C6K,EAAI,CAACR,EAAKC,EAAWX,IACjBS,EAAQ,KAAOC,EAAKC,EAAWX"}