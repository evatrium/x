{"version":3,"file":"routing.js","sources":["src/routing.js"],"sourcesContent":["import { isArray, isObj, createElement, appendChild, extend} from \"./utils\";\nimport {obi} from \"./obi\";\n\nexport const createRouting = () => {\n    let w = window,\n        toValue = (mix) => {\n            if (!mix) return '';\n            var str = decodeURIComponent(mix);\n            if (str === 'false') return false;\n            if (str === 'true') return true;\n            return (+str * 0 === 0) ? (+str) : str;\n        },\n        getParams = (str) => {\n            let tmp, k, out = {}, indi;\n            str = str || w.location.search;\n            indi = str.indexOf(\"?\");\n            if (indi < 0) return;\n            str = str.substr(indi + 1);\n            let arr = str.split('&');\n            while (tmp = arr.shift()) {\n                tmp = tmp.split('=');\n                k = tmp.shift();\n                if (out[k] !== void 0) out[k] = [].concat(out[k], toValue(tmp.shift()));\n                else out[k] = toValue(tmp.shift());\n            }\n            return out;\n        },\n        stringifyParams = (obj) => {\n            var enc = encodeURIComponent, k, i, tmp, str = '';\n            for (k in obj) {\n                if ((tmp = obj[k]) !== void 0) {\n                    if (isArray(tmp)) {\n                        for (i = 0; i < tmp.length; i++) {\n                            str && (str += '&');\n                            str += enc(k) + '=' + enc(tmp[i]);\n                        }\n                    } else {\n                        str && (str += '&');\n                        str += enc(k) + '=' + enc(tmp);\n                    }\n                }\n            }\n            return '?' + str;\n        },\n        getLocation = () => {\n            let {pathname, search} = w.location;\n            return {url: pathname + search, pathname, search, params: getParams()}\n        },\n        setUrl = (path, search, type) => {\n            search = isObj(search) ? stringifyParams(search) : search;\n            w.history[type + 'State'](null, null, path + search)\n        },\n\n        initLoc = getLocation(),\n\n        {url: _lastUrl, pathname: _lastPathname} = initLoc;\n\n    let routing = obi({\n        // pre-pending with $ ignores updates when setting them\n        $lastUrl: _lastUrl,\n        $lastPathname: _lastPathname,\n        $lastType: 'initial',\n        ...initLoc,\n        getParams,\n        stringifyParams,\n        getLocation,\n        route(path, search, type) {\n            type = type || 'push';\n            path = path || location.pathname;\n            search = search || '';\n            const {pathname, url} = getLocation();\n            if (type !== 'replace') (_lastUrl = url, _lastPathname = pathname);\n            setUrl(path, search, type);\n            type === 'replace'\n                ? setTimeout(() => updateLocation({type}))\n                : updateLocation({type});\n        }\n    });\n\n    routing.routerSwitch = ({root, pathMap, noMatch}) => {\n        let next = null, toLast = false,\n            {pathname, $lastPathname, $lastUrl, $lastType, url} = routing,\n            noChange = url === $lastUrl;\n        noMatch = noMatch || '/';\n        if (root) next = pathMap['/' + pathname.split('/')[1]] || pathMap[noMatch];\n        else if (pathMap[pathname]) next = pathMap[pathname];\n        else if ($lastPathname !== pathname && pathMap[$lastPathname]) {\n            routing.route($lastUrl, location.search, 'replace');\n            next = pathMap[$lastPathname];\n            toLast = true;\n        } else if (noMatch && pathMap[noMatch]) {\n            routing.route(noMatch, location.search, 'replace');\n            next = pathMap[noMatch];\n        }\n        return {next, toLast, noChange, replacedLast: $lastType === 'replace'};\n    };\n\n    var updateLocation = (e) => {\n        routing.$merge({\n            ...getLocation(),\n            $lastUrl: e.type === 'popstate' ? routing.url : _lastUrl,\n            $lastPathname: e.type === 'popstate' ? routing.pathname : _lastPathname,\n            $lastType: e.type\n        })\n    };\n\n    w.addEventListener(\"popstate\", updateLocation);\n\n    return routing;\n};\n\nexport const routing = createRouting();\n\n\nexport const CustomElementsRouter = ({transition, pathMap, noMatch, loadingIndicator, lazyMap}) => {\n\n    transition = typeof transition === 'number'\n        ? transition : transition === true ? 150 : 0;\n\n    var initial = true, elem, getMountPoint, timeout,\n        unsub, transitionStyle = `opacity ${transition}ms ease-in-out`,\n        {routerSwitch} = routing, CE = customElements,\n        clearMountingPoint = (e) => {\n            let child = e.lastElementChild;\n            while (child) (e.removeChild(child), child = e.lastElementChild)\n        },\n        m = (parentNode, elem) => (clearMountingPoint(parentNode), appendChild(parentNode, elem)),\n        mount = (elementName, parentNode) => {\n            clearTimeout(timeout);\n            elem = createElement(elementName);\n            if (initial || !transition) return m(parentNode, elem);\n            extend(parentNode.style, {transition: transitionStyle, opacity: 0});\n            timeout = setTimeout(() => {\n                m(parentNode, elem);\n                extend(parentNode.style, {transition: transitionStyle, opacity: 1})\n            }, transition ? transition + 10 : 0);\n        },\n        mountLazy = (elementName, to) => {\n            loadingIndicator && mount(loadingIndicator, to);\n            lazyMap && lazyMap[elementName] && lazyMap[elementName]().then(() =>\n                CE.whenDefined(elementName).then(() =>\n                    // in case of slow network and the user decides to locate somewhere else before\n                    // the request has finished, check that the pathMap matches the element name before exec the mount\n                    // so that the previously requested element doesn't mount over the current\n                    pathMap[location.pathname] === elementName && mount(elementName, to)));\n        },\n        doRoute = () => {\n            let {next, toLast, noChange, replacedLast} = routerSwitch({pathMap, noMatch}),\n                parentNode = getMountPoint && getMountPoint();\n            if (!(parentNode && parentNode.nodeName) || toLast || replacedLast || (noChange && !initial)) return;\n            next && CE.get(next) ? mount(next, parentNode) : mountLazy(next, parentNode);\n        };\n\n    return {\n        mountTo: getNodeToMountToFunction => {\n            unsub && unsub(); // you didn't follow directions!!!\n            getMountPoint = getNodeToMountToFunction;\n            doRoute();\n            initial = false;\n            unsub = routing.$onChange(doRoute);\n            return unsub;\n        }\n    }\n};\n\n\n/*\n\n\nlet router = CustomElementsRouter({\n    transition: 150,\n    loadingIndicator: 'x-circle-loader',\n    noMatch: '/0',\n    pathMap: {\n        '/0': 'intro-0',\n        '/1': 'page-1',\n    },\n    lazyMap: {\n        'intro-0': () => import('./pages/intro-0'),\n        'page-1': () => import('./pages/page-1'),\n    },\n});\n\n\n\n...\n\n lifeCycle() {\n        return router.mountTo(() => this.page_ref);\n }\n\n...\n\n\n\n\n */\n\n\n\n"],"names":["createRouting","w","window","toValue","mix","str","decodeURIComponent","getParams","tmp","k","indi","out","location","search","indexOf","arr","substr","split","shift","concat","stringifyParams","obj","i","enc","encodeURIComponent","isArray","length","getLocation","pathname","url","params","initLoc","_lastUrl","_lastPathname","routing","obi","$lastUrl","$lastPathname","$lastType","route","path","type","isObj","history","setUrl","setTimeout","updateLocation","routerSwitch","root","pathMap","noMatch","next","toLast","noChange","replacedLast","e","$merge","addEventListener","CustomElementsRouter","transition","loadingIndicator","lazyMap","elem","getMountPoint","timeout","unsub","initial","transitionStyle","CE","customElements","m","parentNode","child","lastElementChild","removeChild","clearMountingPoint","appendChild","mount","elementName","clearTimeout","createElement","extend","style","opacity","doRoute","nodeName","get","to","then","whenDefined","mountLazy","mountTo","getNodeToMountToFunction","$onChange"],"mappings":"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"}